# 16. Створення класів

[Перелік усіх робіт](README.md)

## Мета роботи 

Отримати практичні навички реалізації класів С++

## Обладнання

Персональний комп’ютер, Visual Studio 2008 або інша середа розробки для мови C++

## Теоретичні відомості

### Клас.

З погляду синтаксису, клас у С++ це структурований тип, утворений на основі вже існуючих типів. У класі відображено найважливіші концепції об'єктно-орієнтованого програмування: інкапсуляція, успадкування, поліморфізм.

У найпростішому випадку клас можна визначити за допомогою конструкції:

```
class ім'я_класу {
	список_членів_класу;
	список_членів_класу;
	список_членів_класу;
	список_членів_класу;
	список_членів_класу;
};
```
де

`тип_класу` – одне із службових слів `class`, `struct`, `union` ;

`ім'я_класу` – ідентифікатор;

`список_членів_класу` - Визначення та описи типізованих даних і належать класу функцій.

Функції – це методи класу, визначальні операції над об'єктом.

Дані – це поля об'єкта, які утворюють його структуру. Значення полів визначає стан об'єкта.
приклади.

```cpp
struct date{ // дата
	int month,day,year; // Поля: місяць, день, рік
	void set (int, int, int); //метод – встановити дату
	void get(int*,int*,int*); //метод – отримати дату
	void next(); //метод – встановити наступну дату
	void print(); // метод – вивести дату
};
```

```cpp
struct complex {// комплексне число
	double re,im;
	double real(){return(re);}
	double imag(){return(im);}
	void set(double x,double y){re = x; im = y;}
	void print(){cout<<"re = "<<re; cout<<"im = "<<im;}
};
```

Для опису об'єкта класу (екземпляра класу) використовується конструкція `ім'я_класу ім'я_об'єкта;`

```cpp
date today, my_birthday;
date *point = &today; // покажчик на об'єкт типу date
date clim [30]; // масив об'єктів
date &name = my_birthday; // Посилання на об'єкт
```

Об'єкти, що визначаються, входять дані, що відповідають членам - даним класу. Функції члени класу дозволяють обробляти дані конкретних об'єктів класу. Звертатися до даних об'єкта та викликати функції об'єкта можна двома способами. Перший за допомогою "кваліфікованих" імен:

`имя_объекта.имя_данного`
`имя_объекта.имя_функции`


Наприклад:

```cpp
complex x1, x2;
x1.re = 1.24;
x1.im = 2.3;
x2.set(5.1,1.7);
x1.print();
```

Другий спосіб доступу використовує покажчик на

`об'єкт_>об'єкт->ім'я_компонента`

```cpp
complex *point = &x1; // чи point = new complex;
point->re = 1.24;
point->im = 2.3;
point->print ();
```

### Доступність компонентів класу.

У розглянутих прикладах класів компоненти класів є загальнодоступними. У будь-якому місці програми, де "видно" визначення класу, можна отримати доступ до компонентів об'єкта класу. Тим самим не виконується основний принцип абстракції даних – інкапсуляція (приховування) даних усередині об'єкта. Для зміни видимості компонентів у визначенні класу можна використовувати специфікатори доступу: public, private, protected .

Загальнодоступні компоненти (public) доступні в будь-якій частині програми. Вони можуть використовуватися будь-якою функцією як усередині даного класу, так і поза ним. 

Власні (private) компоненти локалізовані в класі і не доступні ззовні. Вони можуть використовуватись функціями – членами даного класу та функціями – "друзями" того класу, в якому вони описані.

Захищені (protected) компоненти доступні всередині класу та у похідних класах.

Змінити статус доступу до компонентів класу можна за допомогою використання у визначенні класу ключового слова class . І тут всі компоненти класу за промовчанням є власними. 

```cpp
class complex{
	double re, im; // private за замовчуванням
	public:
	double real(){return re;}
	double imag(){return im;}
	void set(double x,double y){re = x; im = y;}
};
```

### Конструктор.

Недоліком розглянутих раніше класів є відсутність автоматичної ініціалізації створюваних об'єктів. До кожного новоствореного об'єкта потрібно було викликати функцію типу set (як класу complex) чи явно присвоювати значення даним об'єкта. Однак для ініціалізації об'єктів класу в його визначення можна явно включити спеціальну функцію компоненту, звану конструктором. Формат визначення конструктора наступний:
```
ім'я_класу(список_форм_параметрів){
	оператори_тіла_конструктора;
	оператори_тіла_конструктора;
	оператори_тіла_конструктора;
}
```

Ім'я цієї компонентної функції за правилами мови С++ має співпадати з ім'ям класу. Така функція автоматично викликається при визначенні чи розміщенні у пам'яті за допомогою оператора new кожного об'єкта класу.
приклад.

```cpp
сomplex(double re1 = 0.0, double im1 = 0.0) {
	re = re1; im = im1;
}
```

Конструктор виділяє пам'ять для об'єкта та ініціалізує дані члени класу.

Конструктор має низку особливостей:


>Для конструктора не визначається тип значення, що повертається. Навіть тип void не допустимий.

>Покажчик на конструктор не може бути визначений, і відповідно не можна отримати адресу конструктора.

>Конструктори не успадковуються.

>Конструктори не можуть бути описані з ключовими словами virtual, static, const, mutuable, valatile.


Конструктор завжди існує для будь-якого класу, причому якщо він не визначений явно, він створюється автоматично.

Параметром конструктора може бути його власний клас, але може бути посилання нього (T&). Без явної вказівки програміста конструктор завжди автоматично викликається щодо (створенні) об'єкта. І тут викликається конструктор без параметрів. Для явного виклику конструктора використовуються дві форми:

ім'я класу ім'я об'єкта (фактичні параметри);

ім'я_класу (фактичні_параметри);

Перша форма допускається лише за не порожньому списку фактичних параметрів. Вона передбачає виклик конструктора щодо нового об'єкта даного класу:

complex ss (5.9,0.15);

Друга форма виклику призводить до створення об'єкта без імені: *

complex ss = complex (5.9,0.15);

Існують два способи ініціалізації даних об'єкта за допомогою конструктора. Раніше ми розглядали перший спосіб, а саме, передача значень параметрів тіло конструктора. Другий спосіб передбачає застосування списку ініціалізаторів цього класу. Цей список міститься


між списком параметрів та тілом конструктора. Кожен ініціалізатор списку відноситься до конкретного компонента і має вигляд:

ім'я_даного (вираз)


Приклади.


Клас "символьний рядок".

```cpp
#include <string.h>
#include <iostream>

class string{
	char *ch; // покажчик на текстовий рядок
	int len; // Довжина текстового рядка
	public:
	// Конструктори
	// створює об'єкт - порожній рядок
	string (int N = 80): len (0) {
		ch = new char [N + 1]; 
		ch[0] = '\0';
	}
	// створює об'єкт за заданим рядком
	string (const char * arch) {
		len = strlen (arch);
		ch = new char[len +1];
		strcpy(ch,arch);
	}

	// компоненти-функції
	// повертає посилання на довжину рядка
	int& len_str(void){
		return len;
	}
	// повертає покажчик на рядок
	char *str(void){
		return ch;
	}
};
```

Можна створювати масив об'єктів, однак відповідний клас повинен мати конструктор за замовчуванням (без параметрів).

Масив об'єктів може ініціалізуватися або автоматично за замовчуванням конструктором, або явним присвоєнням значень кожному елементу масиву.

```cpp
class demo{
	int x;
	public:
	demo(){x=0;}
	demo(int i){x=i;}
};

void main () {
	class demo a [20]; //виклик конструктора без параметрів(за замовчуванням)
	class demo b[2]={demo(10),demo(100)
};//явне присвоєння
```

### Деструктор.

Динамічне виділення пам'яті для об'єкта створює необхідність звільнення пам'яті при знищенні об'єкта. Наприклад, якщо об'єкт формується як локальний усередині блоку, то доцільно, щоб при виході з блоку, коли об'єкт перестає існувати, виділена для нього пам'ять була повернута. Бажано, щоб звільнення пам'яті відбувалося автоматично. 

```
~ім'я_класу(){
	оператори_тіла_деструктора;
	оператори_тіла_деструктора;
	оператори_тіла_деструктора;
}
```

Ім'я деструктора збігається з ім'ям його класу, але передує символом "\~" (тильда).

>Деструктор не має параметрів і значення, що повертається. 

>Деструктор виконується не явно (автоматично), як тільки об'єкт класу знищується.

```cpp
string * p = new string("рядок");
delete p;
```
Якщо класі деструктор не визначено явно, то компілятор генерує деструктор за умовчанням, який просто звільняє пам'ять, зайняту даними об'єкта. 

Так само, як і для конструктора, не може бути визначений покажчик на деструктор.



## Хід роботи

1. Завантажити Visual Studio 2008. Знайдіть на робочому столі ярлик з Visual Studio 2008 або Пуск → Всі програми→ Microsoft → Microsoft Visual Studio 2008.

2. Створити новий проект «Visual C++ (консольное приложение Win32)». Файл → Cтворити → Проект, тип проекту «Консольное приложение Win32».

3. Перевірити роботу програми та намалювати блок-схему алгоритму

```cpp
#include <iostream>
using namespace std;

// Оголошення класу Car
class Car {
    public:
        string make;  // марка автомобіля
        string model;  // модель автомобіля
        int year;  // рік випуску автомобіля

        void start() {
            cout << "Starting the " << make << " " << model << "...\n";
        }
};

int main() {
    // Створення об'єкту класу Car з даними про автомобіль
    Car myCar;
    myCar.make = "Toyota";
    myCar.model = "Camry";
    myCar.year = 2021;

    // Виклик методу start() для об'єкту myCar
    myCar.start();

    return 0;
}

```


4. Розв'язати задачу згідно з варіантом. Намалювати блок-схему.
	
	Варіант 1

	Описати клас з ім'ям Student, що містить такі поля:
    - прізвище;
    - номер групи;
    - успішність (масив із 5 елементів).
	
	Написати програму, яка виконує такі дії:
    - введення з клавіатури даних масив, що складається з 10 елементів типу Student;
    - записи впорядкувати за зростанням номера групи;
    - вивести прізвища тих студентів, чий середній бал більший за 4,0. Якщо таких студентів немає, вивести відповідне повідомлення.

    Варіант 2

    Описати клас з ім'ям Aeroflot, що містить такі поля:
    - назву пункту призначення;
    - номер рейсу;
    - тип літака.
	
	Написати програму, яка виконує такі дії:
    - введення з клавіатури даних масив, що складається з 7 елементів типу Aeroflot;
    - записи впорядкувати за зростанням номера рейсу;
    - вивести номери рейсів та типи літаків, що вилітають до пункту призначення, назва якого збіглася з назвою, введеною з клавіатури. Якщо немає, вивести відповідне повідомлення.

    Варіант 3 

    Описати клас з ім'ям Train, що містить такі поля:
    - назву пункту призначення;
    - номер поїзда;
    - час відправлення.

    Написати програму, яка виконує такі дії:
    - введення з клавіатури даних масив, що складається з 8 елементів типу Train;
    - записи упорядкувати в алфавітному порядку за назвами пунктів призначення;
    - вивести інформацію про поїзди, що відправляються після введеного з клавіатури часу. Якщо таких поїздів немає, вивести відповідне сполучення.

    Варіант 4

    Описати клас з ім'ям Marsh, що містить такі поля:
    - назву початкового пункту маршруту;
    - назву кінцевого пункту маршруту;
    - номер маршруту.

    Написати програму, яка виконує такі дії:
    - введення з клавіатури даних масив, що складається з 8 елементів типу Marsh;
    - записи упорядкувати за номерами маршрутів;
    - вивести інформацію про маршрути, що починаються або закінчуються в пункті, назва якого введена з клавіатури. Якщо таких маршрутів немає, вивести відповідне повідомлення.

    Варіант 5

    Описати клас з ім'ям Note, що містить такі поля:
    - прізвище;
    - номер телефону;
    - день народження (масив із 3 чисел).
    
    Написати програму, яка виконує такі дії:
    - введення з клавіатури даних масив, що складається з 8 елементів типу Note;
    - записи упорядкувати за датами днів народження;
    - вивести інформацію про людину, номер телефону якої введено з клавіатури. Якщо цього немає, вивести відповідне повідомлення.

    Варіант 6 

    Описати клас з ім'ям Znak, що містить такі поля:
    - прізвище;
    - знак зодіаку;
    - день народження (масив із 3 чисел).
    
    Написати програму, яка виконує такі дії:
    - введення з клавіатури даних масив, що складається з 8 елементів типу Znak;
    - записи упорядкувати за датами днів народження;
    - вивести інформацію про людину, чиє прізвище введене з клавіатури. Якщо цього немає, вивести відповідне повідомлення.

    Варіант 7

    Описати клас з іменем Price, що містить такі поля:
    - Назва товару;
    - назва магазину, у якому продається товар;
    - вартість товару у рублях.
    
    Написати програму, яка виконує такі дії:
    - введення з клавіатури даних масив, що складається з 8 елементів типу Price;
    - записи впорядкувати за абеткою щодо назви товару;
    - вивести інформацію про товар, назву якого введено з клавіатури. Якщо таких товарів немає, вивести відповідне повідомлення.

    Варіант 8

    Описати клас з ім'ям Order, що містить такі поля:
    - розрахунковий рахунок платника;
    - розрахунковий рахунок отримувача;
    - сума, що перераховується в рублях.
    
    Написати програму, яка виконує такі дії:
    - введення з клавіатури даних масив, що складається з 8 елементів типу Order;
    - записи упорядкувати в алфавітному порядку за розрахунковими рахунками платника;
    - вивести інформацію про суму, зняту з розрахункового рахунку платника, запровадженого з клавіатури. Якщо такого розрахункового рахунку немає, вивести відповідне повідомлення.

    Варіант 9

    Описати клас з ім'ям Student, що містить такі поля:
    - прізвище;
    - номер групи;
    - успішність (масив із 5 елементів).
    
    Написати програму, яка виконує такі дії:
    - введення з клавіатури даних масив, що складається з 10 елементів типу Student;
    - записи впорядкувати за зростанням середнього бала;
    - вивести прізвища студентів, які мають оцінки 4 та 5. Якщо таких студентів немає, вивести відповідне повідомлення.

    Варіант 10

    Описати клас з ім'ям Aeroflot, що містить такі поля:
    - назву пункту призначення;
    - номер рейсу;
    - тип літака.
	
	Написати програму, яка виконує такі дії:
    - введення з клавіатури даних масив, що складається з 7 елементів типу Aeroflot;
    - записи упорядкувати в алфавітному порядку за назвами пунктів призначення;
    - вивести пункти призначення та номери рейсів, які обслуговує літак, тип якого введений з клавіатури. Якщо таких рейсів немає, вивести відповідне повідомлення.

## Контрольні запитання

1. Що таке класи в програмуванні та для чого вони використовуються?
2. Як створити клас у С++?
3. Яка різниця між класом та об'єктом у С++?
4. Як створити екземпляр класу у С++?
5. Що таке конструктор класу і яку роль він відіграє?
6. Які є типи конструкторів у С++?
7. Що таке деструктор класу і яку роль він відіграє?
8. Які є доступні рівні доступу до членів класу в С++?
9. Як відбувається доступ до членів класу ззовні у С++?
10. Які є основні принципи ООП в С++ та як вони пов'язані з класами і об'єктами?

## Довідники та додаткові матеріали

1.  [GeeksforGeeks - Object Oriented Programming(OOPs) Concept in C++](https://www.geeksforgeeks.org/object-oriented-programming-oops-concept-in-c/)
2.  [W3Schools - C++ OOP](https://www.w3schools.com/cpp/cpp_oop.asp)
3.  [TutorialsPoint - C++ Object Oriented](https://www.tutorialspoint.com/cplusplus/cpp_object_oriented.htm)
4.  [Programiz - C++ Object-oriented Programming](https://www.programiz.com/cpp-programming/object-oriented-programming)
5.  [Learn-C - Object Oriented Programming](https://www.learn-c.org/en/Object_Oriented_Programming)
6.  [cplusplus.com - Classes (I)](https://www.cplusplus.com/doc/tutorial/classes/)
7.  [Udemy - Object-Oriented Programming in C++](https://www.udemy.com/topic/object-oriented-programming-in-c-plus-plus/)
8.  [ООП в С++. Поліморфізм і наслідування](https://www.viva64.com/en/t/0079/)
9.  [Основы ООП в С++. Классы и объекты](https://metanit.com/cpp/tutorial/4.1.php)
10. [LearnCpp: Introduction to Object Oriented Programming (OOP) in C++](https://www.learncpp.com/cpp-tutorial/object-oriented-programming/)
11. [Cplusplus.com: Polymorphism](https://www.cplusplus.com/doc/tutorial/polymorphism/)
12. [GeeksforGeeks: Object Oriented Programming (OOPs) Concept in C++](https://www.geeksforgeeks.org/object-oriented-programming-oops-concept-in-c/)
13. [JavaTpoint: C++ OOPs Concepts](https://www.javatpoint.com/cpp-oops-concepts)
14. [OOP in C++ - YouTube Playlist by Neso Academy](https://www.youtube.com/watch?v=_bYFu9mBnr4&list=PLBlnK6fEyqRgp46KUv4ZY69yXmpwKOIev)