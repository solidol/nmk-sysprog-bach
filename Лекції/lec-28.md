# Стандарт OpenMP ч.1

[Перелік лекцій](README.md)

## Узагальнено

OpenMP - це API (Application Programming Interface), що дозволяє розробникам вбудовувати паралельні можливості в свої програми, що запускаються на багатопроцесорних та багатоядерних системах. Це стандарт, що розробляється спільнотою виробників обладнання, ПЗ та університетів, тому його реалізації доступні на більшості платформ.

OpenMP дозволяє розпаралелити певні ділянки коду програми, що називаються областями паралельного кодування, і виконувати їх на декількох потоках в одному процесі. Для цього використовуються директиви компілятора, які вказують на те, які частини коду мають виконуватись паралельно. OpenMP підтримує різні види паралелізму, включаючи паралелізм на рівні циклів, функцій та даних.

OpenMP є дуже популярним серед програмістів, які бажають зробити свої програми ефективнішими на багатоядерних системах. Він є простим у використанні та не вимагає глибоких знань з паралельного програмування. За допомогою OpenMP розробники можуть швидко та легко перетворити існуючий однопотоковий код у паралельний, що забезпечує збільшення продуктивності їх програм. Однак, OpenMP має свої обмеження та недоліки, такі як обмеження на кількість доступних потоків та недостатня гнучкість у виборі конфігурації паралелізму.

Стандарт OpenMP розробляється і підтримується консорціумом OpenMP Architecture Review Board (ARB), до складу якого входять компанії-розробники програмного забезпечення, наукові установи та інші організації. Крім того, консорціум взаємодіє зі спільнотою користувачів та розробників OpenMP для забезпечення розвитку стандарту у відповідності до потреб користувачів та прогресу в галузі розробки ПЗ.

## Директиви

Директива OpenMP - це спеціальний технічний термін, що означає певні інструкції для компілятора, які дозволяють розпаралелювати код на багатоядерних архітектурах. Директиви OpenMP можуть бути вбудованими у код програми та містять спеціальні конструкції мови C/C++/Fortran, що вказують на те, які частини програми можуть бути виконані паралельно, які змінні є спільними для всіх потоків, які змінні є приватними для кожного потоку тощо.

Основні директиви:

| Назва директиви | Опис |
| --- | --- |
| parallel | створює команду для запуску паралельного коду. |
| for | розпаралельовує цикл. |
| sections | розпаралельовує блоки коду між директивами section. |
| section | вказує на блок коду для паралельного виконання у межах sections. |
| single | виконується лише одним потоком. |
| master | виконується лише мастер-потоком. |
| critical | виконується лише одним потоком в даний момент часу. |
| atomic | виконує атомічну операцію над змінною. |
| barrier | чекає, поки всі потоки дійдуть до цієї директиви. |
| ordered | забезпечує послідовну виконання блоку коду для кожного потока. |
| threadprivate | вказує, що змінна повинна бути приватною для кожного потока. |
| flush | синхронізує пам'ять між потоками. |
| reduction | виконує редукцію для заданої змінної. |
| task | визначає задачу, яка може бути виконана паралельно. |
| depend | вказує залежності між задачами. |
| target | вказує, що блок коду повинен бути виконаний на віддаленому пристрої. |
| teams | розділяє потоки на команди. |
| distribute | розділяє ітерації циклу між командами. |
| simd | дозволяє виконувати обчислення на векторах. |
| declare | вказує атрибути змінних. |



Для розпаралелювання циклів у OpenMP використовуються директиви #pragma omp parallel for, яка розпаралелює цикли та розподіляє їх між потоками, та директива #pragma omp simd, яка дозволяє компілятору автоматично використовувати векторизацію для оптимізації циклів, що обробляють векторні дані.

Для розпаралелювання областей коду в OpenMP можна використовувати директиву #pragma omp parallel, яка позначає область коду, яка повинна бути виконана паралельно у всіх потоках, та директиву #pragma omp sections, яка дозволяє ділити область коду на окремі секції та розподіляти їх між потоками. Також можна використовувати директиву #pragma omp task, яка позначає окрему задачу, яка може бути виконана паралельно з іншими задачами та забезпечує динамічну роботу з потоками.


## Приклад
```cpp
#include <iostream>
#include <omp.h>

#define ARRAY_SIZE 1000000

int main() {
    int array[ARRAY_SIZE];
    int sum = 0;

// Ініціалізуємо масив
    for (int i = 0; i < ARRAY_SIZE; i++) {
        array[i] = i;
    }

// Обчислюємо суму елементів масиву за допомогою декількох потоків
    #pragma omp parallel for reduction(+:sum)
    for (int i = 0; i < ARRAY_SIZE; i++) {
        sum += array[i];
    }

// Виводимо результат
    std::cout << "Sum of array elements = " << sum << std::endl;

    return 0;
}
```
У цій програмі масив розміром 1000000 елементів ініціалізується в основному потоці. Після цього виконується паралельний цикл за допомогою директиви #pragma omp parallel for, яка розбиває цикл на частини та запускає кожну частину в окремому потоці. Директива reduction(+:sum) вказує, що змінна sum повинна бути підрахована як сума всіх часткових сум з окремих потоків.

На виході програма виводить загальну суму масиву на екран.

## Контрольні запитання

1.  Що таке OpenMP?
2.  Для чого використовують OpenMP?
3.  Що таке директива OpenMP?
4.  Які директиви OpenMP використовують для розпаралелювання циклів?
5.  Які директиви OpenMP використовують для розпаралелювання областей коду?
6.  Які параметри використовують для задання кількості потоків у програмі OpenMP?
7.  Які параметри використовують для задання розміру чанку у циклах в OpenMP?
8.  Які директиви OpenMP використовують для синхронізації потоків?
9.  Як відключити розпаралелювання в деяких частинах програми?
10.  Як можна отримати доступ до змінних з окремих потоків у OpenMP?
