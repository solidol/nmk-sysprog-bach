# Функції та бібліотеки функцій

[Перелік лекцій](README.md)

## Узагальнено про функції

Функція (англ. function) - це блок коду в програмі, який виконує конкретну задачу і може бути викликаний з інших частин програми для повторного використання та підтримки модульності.

Функції можуть приймати вхідні параметри, які використовуються в тілі функції для виконання певних операцій, і повертати вихідні значення, які можуть використовуватися в інших частинах програми. Функції також можуть викликати інші функції та змінювати значення змінних в інших частинах програми.

Функції забезпечують ефективність і повторне використання коду, тому що коли функція була розроблена, вона може бути використана в будь-якій частині програми, де є необхідність у виконанні певної задачі.

Функції є основною будівельною одиницею програм, що дозволяє розбити програму на менші логічні блоки і полегшити її розуміння та збереження.

У загальному вигляді оголошення функції виглядає наступним чином:

```
[тип повернення] ім'я_функції ([параметри]) {
    // тіло функції
    return [вираз]; // необов'язково, якщо тип повернення void
}
```

- **[тип повернення]** - тип даних, який функція повертає після виконання. Якщо функція не повертає нічого, то тип повернення вказується як void.
- **ім'я_функції** - унікальне ім'я функції, яке використовується для її виклику.
- **[параметри]** - список змінних, які можуть бути передані функції при її виклику. Якщо функція не очікує жодного параметру, то вказується (void) або ().
- **return** - ключове слово, яке вказує на повернення значення з функції.
- **[вираз]** - вираз, результат якого повертається з функції.

Приклад оголошення та виклику функції:

```cpp
int sum(int a, int b) {
     return a + b;
}

int main() {
     int result = sum(2, 3);
     return 0;
}
```

## Прототип функції 

Прототип функції - це опис функції, який містить інформацію про її типи параметрів та поверненого значення. Прототип функції не містить тіла функції, а лише її сигнатуру.

Прототип функції є важливим елементом в програмуванні, оскільки він дозволяє компілятору знати, які аргументи передаються у функцію і який тип значення функція повертає. Це дозволяє перевіряти правильність виклику функції та її параметрів під час компіляції програми.

Прототип функції зазвичай містить ім'я функції, тип поверненого значення, типи та імена параметрів функції. Наприклад:

```cpp
int add(int x, int y); // Прототип функції "add"
```

У цьому прикладі, "add" - ім'я функції, "int" - тип значення, що повертається, "x" та "y" - імена та типи параметрів функції. Такий прототип можна розмістити відразу після директиви #include у початку файлу з кодом програми або в окремому заголовочному файлі, який може бути включений в програму за допомогою директиви #include.

Окрім того, прототипи функції є складовою заголовкових файлів.

Заголовковий файл (англ. header file) - це файл, який містить оголошення функцій, змінних та інших об'єктів, які можуть бути використані в програмі. Заголовкові файли зазвичай містять лише оголошення, а не визначення функцій або змінних.

У мові програмування C++ заголовкові файли використовуються для того, щоб забезпечити взаємодію між різними частинами програми. Наприклад, якщо програма складається з декількох файлів, які містять функції, то заголовковий файл може містити оголошення цих функцій, які потім можуть бути використані в інших файлах програми.

Заголовкові файли можуть також містити директиви препроцесора, які дозволяють включати інші файли, а також макроси, які визначаються для використання в програмі.

Заголовкові файли зазвичай мають розширення .h або .hpp і їх можна включати в програму за допомогою директиви #include.


## Передача аргументів за значенням
Аргументи можуть передаватися за значенням (by value) та за посиланням (by reference). При передачі аргументів за значенням зовнішній об'єкт, який передається як аргумент у функцію, може бути змінено у цій функції. У функцію передається саме значення цього об'єкта. Наприклад:

```cpp
#include <iostream>
 
void square (int, int);
 
int main()
{
     int a = 4;
     int b = 5;
     std::cout << "Before square: a = " << a << "\tb=" << b << std::endl;
     square(a, b);
     std::cout << "After square: a = " << a << "\tb=" << b << std::endl;
 
     return 0;
}
void square(int a, int b)
{
     a = a * a;
     b = b * b;
     std::cout << "In square: a = " << a << "\tb=" << b << std::endl;
}
```
Функція square приймає два числа та зводить їх у квадрат. У функції main перед і після виконання функції square відбувається виведення на консоль значень змінних a і b, які передаються в square як аргументи.

І при виконанні ми побачимо, що зміни аргументів функції square діють тільки в рамках цієї функції. Поза її значенням змінних a і b залишаються незмінними:

Before square: a = 4 b = 5
In square: a = 16 b = 25
After square: a = 4 b = 5
Чому так відбувається? При компіляції функції її параметрів виділяються окремі ділянки пам'яті. При виклику функції обчислюються значення аргументів, які передаються місце параметрів. І потім значення аргументів заносяться до цих ділянок пам'яті. Тобто функція маніпулює копіями значень об'єктів, а чи не самими об'єктами.

## Передача параметрів за посиланням
При передачі параметрів посилання передається посилання на об'єкт, якою ми можемо маніпулювати самим об'єктів, а чи не просто його значенням. Так, перепишемо попередній приклад, використовуючи передачу за посиланням:

```cpp
#include <iostream>
 
void square(int&, int&);
 
int main()
{
     int a = 4;
     int b = 5;
     std::cout << "Before square: a = " << a << "\tb=" << b << std::endl;
     square(a, b);
     std::cout << "After square: a = " << a << "\tb=" << b << std::endl;
 
     return 0;
}
void square(int &a, int &b)
{
     a = a * a;
     b = b * b;
     std::cout << "In square: a = " << a << "\tb=" << b << std::endl;
}
```
Тепер параметри a та b передаються за посиланням. Посилальний параметр зв'язується безпосередньо з об'єктом, тому через посилання можна міняти сам об'єкт.

І якщо ми скомпілюємо та запустимо програму, то результат буде іншим:

```
Before square: a = 4 b = 5
In square: a = 16 b = 25
After square: a = 16 b = 25
```
Передача посилання дозволяє повернути з функції відразу кілька значень. Також передача параметрів посилання є більш ефективною при передачі дуже великих об'єктів. Оскільки в цьому випадку немає копіювання значень, а функція використовує сам об'єкт, а не його значення.

Від передачі аргументів за посиланням слід відрізняти передачу посилань як аргументи:

```cpp
#include <iostream>
 
void square (int, int);
 
int main()
{
     int a = 4;
     int b = 5;
     int &aRef = a;
     int &bRef = b;
     std::cout << "Before square: a = " << a << "\tb=" << b << std::endl;
     square(aRef, bRef);
     std::cout << "After square: a = " << a << "\tb=" << b << std::endl;
 
     return 0;
}
void square(int a, int b)
{
     a = a * a;
     b = b * b;
     std::cout << "In square: a = " << a << "\tb=" << b << std::endl;
}
```
Якщо функція приймає аргументи за значенням, то зміна параметрів усередині функції також ніяк не позначиться на зовнішніх об'єктах, навіть якщо виклику функції до неї передаються посилання на об'єкти.

```
Before square: a = 4 b = 5
In square: a = 16 b = 25
After square: a = 4 b = 5
```
Передача параметрів за значенням більше підходить для передачі у функцію невеликих об'єктів, значення яких копіюються у певні ділянки пам'яті, які потім використовує функція.

Передача параметрів за посиланням більше підходить для передачі у функцію великих об'єктів, у цьому випадку не потрібно копіювати весь вміст об'єкта в ділянку пам'яті, за рахунок чого продуктивність програми збільшується.

## Модулі

Модуль — це набір файлів вихідного коду, які компілюються незалежно. Вони не впливають на компіляцію одиниці програми, що імпортує модуль. Модулі можна імпортувати в будь-якому порядку, не переймаючись перевизначенням макросів. Оголошення в блоці імпорту перекладу не беруть участі у дозволі навантаження або пошуку імен в імпортованому модулі. Після компіляції модуля один раз результати зберігаються у двійковому файлі, в якому описуються всі експортовані типи, функції та шаблони. Компілятор може обробляти цей файл набагато швидше, ніж заголовок. Компілятор може повторно використовувати його у будь-якому місці імпорту модуля у проект.

Модулі можна використовувати паралельно із файлами заголовків. Вихідний файл C++ може містити importмодулі та #includeфайли заголовків. У деяких випадках файл заголовка можна імпортувати як модуль, а не включати його в текст за допомогою #includeпрепроцесора. Ми рекомендуємо використовувати модулі у нових проектах, а не файли заголовків якнайбільше. Для більших існуючих проектів, які активно розробляються, поекспериментуйте з перетворенням застарілих заголовків у модулі. Грунтуйте своє використання на тому, чи отримуєте ви значне скорочення часу компіляції.

## Створення та використання бібліотеки

У С++, бібліотеки - це набір написаних кодом функцій, класів та інших корисних ресурсів, які можуть бути використані для розв'язування певних задач. Бібліотеки можуть бути вбудовані в мову С++ або створені користувачем. Вони містять готовий до використання код, який може бути включений в програму.

Зазвичай, бібліотека складається з основного файлу з кодом (.cpp) та окремого заголовкового (.h, .hpp).

Створення бібліотеки у С++ може бути здійснене у кілька кроків:

1. Написання коду функцій та інших об'єктів, які мають бути включені до модулю.
2. Створення файлу з розширенням ".cpp", у якому міститься весь код модуля.
3. Визначення функцій та інших об'єктів у заголовочному файлі з розширенням ".h", який буде включатися до будь-якої частини програми, що використовує модуль.
4. Включення заголовочного файлу у інші файли, які використовують модуль.


Приклад бібліотеки та заголовкового файлу до нього

```cpp
// Файл mymodule.h
#ifndef MYMODULE_H
#define MYMODULE_H

int add(int a, int b);

#endif
```

```cpp
// Файл mymodule.cpp
#include "mymodule.h"

int add(int a, int b) {
    return a + b;
}
```