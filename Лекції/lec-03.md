# Типи даних. Змінні. Константи. Класи пам'яті

[Перелік лекцій](README.md)

## Типи даних

Обробка даних різного типу є головною метою будь-якої програми. Кожне з даних характеризується класом пам’яті, ім’ям, типом і значенням. Імена дозволяють ідентифікувати дані, тобто відрізняти їх між собою. Програміст обирає тип кожної величини, що використовується для подання реальних об’єктів. Тип задає множину можливих значень даних і способи їх зберігання, перетворення та використання.

**Обов’язкове оголошення типу даних дозволяє** компілятору робити перевірку допустимості різних конструкцій програми.

Усі типи даних мови C++ можна розділити на **основні** (базові) і **складені**. Основні типи визначені для представлення цілих, дійсних, символьних і логічних даних. На основі цих типів вводиться опис складених типів, до яких належать масиви, перелічення, функції, структури, посилання, покажчики, об’єднання і класи.

**Основні типи даних** (див. табл. 3.1) часто називають арифметичними, тому що їх можна використовувати в арифметичних операціях. Для опису основних типів мови C++ використовують такі службові слова:

*   **int** (цілий);
*   **char** (символьний);
*   **bool** (логічний);
*   **float** (дійсний);
*   **double** (дійсний з подвійною точністю);
*   **void** (порожній, не має значення).

Типи **int, char, bool** називають **цілими**, а типи **float** та **double** — **дійсними з плаваючою крапкою**. Код, що формує компілятор для обробки цілих величин, відрізняється від коду для величин з плаваючою крапкою.

Для уточнення внутрішнього подання та діапазону значень стандартних типів **мова C++ використовує чотири специфікатори типу**:

*   **short** (короткий);
*   **long** (довгий);
*   **signed** (знаковий);
*   **unsigned** (беззнаковий).

Таблиця З.1

Базові типи даних для ПК (платформа Intel)

<table border="1" width="100%">

<tbody>

<tr>

<td width="40%">Тип</td>

<td width="10%">Розмір, байт</td>

<td width="50%">Значення</td>

</tr>

<tr>

<td>**bool**</td>

<td>1</td>

<td>true або false</td>

</tr>

<tr>

<td>**unsigned short int**</td>

<td>2</td>

<td>від 0 до 65 535</td>

</tr>

<tr>

<td>**short int**</td>

<td>2</td>

<td>від -32 768 до 32 767</td>

</tr>

<tr>

<td>**unsigned long int**</td>

<td>4</td>

<td>від 0 до 4 294 967 295</td>

</tr>

<tr>

<td>**long int**</td>

<td>4</td>

<td>від -2 147 483 648 до 2 147 483 647</td>

</tr>

<tr>

<td>**int** (16 розрядів)</td>

<td>2</td>

<td>від -32 768 до 32 767</td>

</tr>

<tr>

<td>**int** (32 розряди)</td>

<td>4</td>

<td>від -2 147 483 648 до 2 147 483 647</td>

</tr>

<tr>

<td>**unsigned int** (16 розрядів)</td>

<td>2</td>

<td>від 0 до 65 535</td>

</tr>

<tr>

<td>**unsigned int** (32 розряди)</td>

<td>4</td>

<td>від 0 до 4 294 967 295</td>

</tr>

<tr>

<td>**char**</td>

<td>1</td>

<td>від 0 до 256</td>

</tr>

<tr>

<td>**float**</td>

<td>4</td>

<td>від 1.2е-38 до 3.4е38</td>

</tr>

<tr>

<td>**double**</td>

<td>8</td>

<td>від 2.2е-308 до 1.8е308</td>

</tr>

<tr>

<td>**long double**</td>

<td>10</td>

<td>від 3.4е-4932 до 3.4е+4932</td>

</tr>

</tbody>

</table>

У табл. 3.1 наведено діапазони значень та розміри основних типів даних (для 16-розрядного і 32-розрядного процесорів). Розмір однакового типу даних може відрізнятися на комп’юте­рах різних платформ, а також може залежати від застосованої операційної системи. Тому при оголошенні тієї чи іншої змінної потрібно чітко уявляти, скільки байт вона буде займати в пам’яті ЕОМ, щоб запобігти проблемам, пов’язаним з переповнен­ням і неправильною інтерпретацією даних. Діапазони кожного з типів (див. табл. 3.1) повинні бути перевірені для конкретного комп’ютера.

## Змінні

Кожна програма потребує виконання різноманітних обчислень, для здійснення яких використовуються вирази, що складаються з операндів, знаків операцій і дужок. Операнди задають дані для обчислень, а операції задають дії, які необ­хiдно виконати над цими даними. Операнд є, у свою чергу, виразом, що в окремому випадку може бути константою або змінною.

**Змінна** — це іменована область пам’яті, у якій зберігаються дані визначеного типу. Змінна має ім’я, розмір та інші атрибути, такі як видимість, час існування тощо. Ім’я змінної служить для звертання до області пам’яті, у якій зберігається її значення. **Перед використанням будь-яка змінна повинна бути описана**, при цьому для неї резервується деяка область пам’яті, розмір якої залежить від конкретного типу змінної. Під час виконання програми змінна може приймати рiзнi значення.

Наведемо загальний вигляд опису змінних:

```cpp
[клас пам’яті] [const] тип ім’я [ініціювання];
```

де необов’язковий клас пам’яті може приймати одне зі значень — **auto, extern, static** чи **register** (у посібнику при описі синтаксису об’єктів програмування необов’язкові частини синтаксичних конструкцій мови подано у квадратних дужках «[]»);

модифікатор **const** вказує, що змінна не може змінювати своє значення, у цьому випадку її називають **типізованою (іменованою) константою** або просто **константою**;

**ініціювання** — це присвоювання змінній при описі початкового значення, яке записується зі знаком рівності — **= значення** або в круглих дужках — (**значення**). Зазначимо, що константа **повинна бути ініційована при описі**. Один оператор може містити опис декількох змінних одного типу, розділяючи їх кома­ми, наприклад:

```cpp
const int n = 20, m = 5, k = 4; // — ініціювання констант n, m, k цілого типу;
float h = 17.5, d(5.5), sum; // — опис дійсних змінних h, d, sum, ініціювання h і d;
char sf = 'f', st[ ] = "Мудрость лишь в истине."; // — ініціювання символьних змінних.
```

Якщо **тип** значення, що ініціюється, не збігається з типом змінної, то виконуються перетворення типу. Кожна змінна повинна мати своє ім’я, причому в одному блоці не може бути двох змінних з однаковим ім’ям.

**Областю дії ідентифікатора змінної** є частина програми, в якій його можна використовувати для доступу до зв’язаної з ним області пам’яті. Залежно від області дії змінна може бути локальною або глобальною.

**Локальна змінна** визначена всередині блока (нагадаємо, що блок розташований між фігурними дужками). Область її дії обмежена початком опису змінної та кінцем блока, включаючи усі вкладені блоки. Змінна, визначена поза будь-яким блоком, називається глобальною, і областю її дії вважається файл, у якому вона визначена від початку опису до його кінця.

**Клас пам’яті** визначає час існування та область видимості програмного об’єкта, тобто змінної. Якщо клас пам’яті не зазначений явно, то він визначається компілятором, виходячи, з контексту оголошення.

**Час існування** змінної може бути постійним (протягом виконання програми) і тимчасовим (протягом виконання блока).

**Областю видимості** ідентифікатора називається частина тексту програми, з якої можна здійснити звичайний доступ до зв’язаної з ідентифікатором області пам’яті. Найчастіше область видимості збігається з областю дії. Винятком є ситуація, коли у вкладеному блоці описана змінна з таким же ім’ям. У цьому випадку зовнішня змінна у вкладеному блоці невидима, хоча він і входить до її області дії. Проте до цієї змінної, якщо вона глобальна, можна звернутися, застосовуючи операцію доступу до області видимості — **::**.

Клас пам’яті задають такі специфікатори:

*   **auto** — автоматична змінна, для якої пам’ять виділяється у стеку і за необхідності ініціюється кожного разу при виконанні оператора, що містить її визначення. Звільнення пам’яті відбувається при виході з блока, де описана змінна. Час її існування — з моменту опису до кінця виконання блока. Для глобальних змінних цей специфікатор не використовується, а для локальних він приймається за замовчуванням, тому задавати його явно великого сенсу немає;
*   **extern** означає, що змінна визначена в іншому місці програми (в іншому файлі або далі по тексту) і використовується для створення змінних, доступних в усіх модулях програми, де вони оголошені. При ініціюванні змінної у тому ж операторі, спеціфікатор **extern** ігнорується;
*   **static** — статична змінна, що має постійний час існування. Вона ініціюється один раз при першому виконанні oпe­ратора, що містить визначення змінної. Залежно від розташування оператора, описані статичні змінні можуть бути глобальними і локальними. Глобальні статичні змінні видимі тільки у тому модулі, в якому вони описані;
*   **register** — аналогічний до специфікатора **auto**, але пам’ять видiляється по можливості в регістрах процесора і за відсутності такої можливості у компілятора змінні обробляються як **auto**.

Наведемо фрагмент програми з використанням розглянутих вище понять:

```cpp
int d;               //1 — глобальная переменная d
int main()
{
    int b;              //2 — локальная переменная b
    extern int y;     //3 — переменная у определена в другом месте программы 
    static int s;      //4 — локальная статическая переменная s
    d = 1;           //5 — присваивание значения глобальной переменной 
    int d;            //6 — локальная переменная d
    d = 10;         //7 — присваивание значения локальной переменной
    ::d = 3;        //8 — присваивание значения глобальной переменной 
    return 0;
}
int у = 4;       // 9 — определение и инициализация переменной у
```

У цьому прикладі глобальна змінна **d** визначена поза всіма блоками. Пам’ять для неї виділяється в сегменті даних на початку роботи програми, областю дії є вся програма. Область видимості — вся програма, крім рядків 6-8, тому що в першому з них визначається локальна змінна з тим же ім’ям, область дії якої починається з початку її опису і закінчується при виході з блока. Змінні **b i s** — локальні, область їх видимості — блок, але час існування різний: пам’ять під **b** виділяється в стеку при вході у блок і звільняється при виході з нього, а змінна **s** розташована у сегменті даних та існує увесь час роботи програми. Якщо початкове значення змінних явно не задається, компілятор присвоює глобальним і статичним змінним нульове значення відповідного типу. Автоматичні змінні не ініціюються. **Початкове ініціювання змінних не є обов’язковим, проте все ж його бажано здійснювати**.

Опис змінної може виконуватися у формі оголошення або визначення. Оголошення інформує компілятор про тип змінної і класи пам’яті, а **визначення** містить, крім цього, вказівку компілятору про виділення пам’яті відповідно до типу змінної. У C++ більшість оголошень є одночасно і визначеннями (у наведеному вище програмному фрагменті тільки опис **extern int у**; є оголошенням, але не визначенням). **Змінна може бути оголошена багаторазово, а визначена тільки в одному місці програми**, оскільки оголошення тільки описує властивості змінної, а визначення зв’язує її з конкретною областю пам’яті.

Розглянемо далі основні типи змінних.

**Цілі змінні** (типу **int, long, short**) необхідні для збереження цілих значень і можуть бути знаковими і беззнаковими. Знакові змінні застосовують для подання як додатних, так і від’ємних чисел, при цьому один біт (найстарший) виділяється під знак. Для оголошення беззнакової змінної, тобто змінної, що приймає тільки додатні значення, необхідно використовувати ключове слово **unsigned**. За замовчуванням будь-який цілий тип вважається знаковим, і тому немає потреби у використанні ключового слова **signed**.

**Символьний тип** даних **char** застосовується у випадку, коли змінна містить інформацію про код ASCII або для побудови таких більш складних конструкцій, як рядки, символьні масиви тощо. Дані типу **char** також можуть бути знаковими і беззнаковими.

**Змінна типу bool** займає 1 байт і використовується, насамперед, у логічних операціях, тому що може приймати значення **0** (**false** — «неправда») або відмінне від нуля (**true** — «істина»). У випадку перетворення до цілого типу **true** має значення 1.

Стандарт C++ визначає три типи даних для збереження **дійсних значень змінних**: **float, double** та **long double** (типи **з плаваючою крапкою**). Тип **float**, як правило, використовують для збереження не дуже великих дробових чисел.

**Змінна типу void** не має значення, оскільки множина значень цього типу порожня. Такі змінні необхідні для узгодження синтаксису. Тип **void** використовується для визначення функцій, що не повертають значення, для вказівки порожнього списку аргументів функції, а також як базовий тип для покажчиків i в операції приведення типів. Наприклад, якщо немає потреби у використанні поверненого значення функції, перед ім’ям функції ставиться тип **void**:

```cpp
void minmax(int*x, int k, int*min, int&max);
```

## Константи

Константи являють собою фіксовані значення, що не мо­жуть змінюватися впродовж виконання всієї програми.

Спосіб визначення кожної константи залежить від її типу. Константи мови С++ слід поділяти на літеральні та типізовані.

**Літеральна константа**— це лексема, що являє собою зо­браження фіксованого числового, рядкового або символьного значення. Такі константи бувають **цілі, дійсні, символьні та рядкові**(<span style="font-weight: normal; font-style: italic;">табл. 3.2).</span>

<table border="0" width="663" cellspacing="0" cellpadding="0">

<tbody>

<tr>

<td valign="top" width="112">Таблиця 3.2</td>

<td valign="top" width="361">

Літеральні константи мови

</td>

<td valign="top" width="190"></td>

</tr>

<tr>

<td valign="top" width="112">

Константа

</td>

<td valign="top" width="361">

Формат

</td>

<td valign="top" width="190">

Приклади

</td>

</tr>

<tr>

<td valign="top" width="112">Цiла</td>

<td valign="top" width="361">Десятковий: послідовність десяткових цифр  
(0, 1, 2, 3, 4, 5, 6, 7, 8, 9),  
що починається не з нуля, якщо це не число нуль</td>

<td valign="top" width="190">9, 0, 217925</td>

</tr>

<tr>

<td valign="top" width="112"></td>

<td valign="top" width="361">Вісімковий: нуль, за яким розташова­ні вісімкові цифри  
(0, 1, 2, 3, 4, 5, 6, 7)</td>

<td valign="top" width="190">02, 050, 07245</td>

</tr>

<tr>

<td valign="top" width="112"></td>

<td valign="top" width="361">Шістнадцятковий: 0х чи 0Х, за яким розташовані шістнадцяткові цифри  
(0, 2, 3, 4, 5, 6, 7, 8, 9, А, В, С, D, Е, F)</td>

<td valign="top" width="190">0x1B9, 0X00FF</td>

</tr>

<tr>

<td valign="top" width="112">Дійсна</td>

<td valign="top" width="361">Десятковий:[цифри].[цифри]Експоненціальний:  
[цифри][.][цифри]{Е|е}[+|-][цифри]</td>

<td valign="top" width="190">9.7, .001, 87\. 0.7Е6, .15е-3 9.2, 920 е-2, 92.Е-1, .92Е1</td>

</tr>

<tr>

<td valign="top" width="112">Символьна</td>

<td valign="top" width="361">Один чи два символи, що подаються в апострофах</td>

<td valign="top" width="190">‘А’ , ‘ю’ , ‘* ‘ , ‘db’ ,  
’\0′, ‘\n’, ’\012′,  
‘\х07\х07’</td>

</tr>

<tr>

<td valign="top" width="112">Рядкова</td>

<td valign="top" width="361">Послідовність символів, що подають­ся в лапках</td>

<td valign="top" width="190">RESULT”,  
\t sum__s=\0x5\n”</td>

</tr>

</tbody>

</table>

**Цілі константи** можуть бути десятковими, вісімковими та шiстнадцятковими.

Довгі цілі константи (**long**) мають літеру **l** або **L** в кінці, наприклад: 32768L; 0777777l; 0XFL. Для завдання константи, без знака (**unsigned**) застосовується літера **u (U)**,наприклад 65535u. Довгі константи без знака записуються з використанням двох літер відразу: **(ul, UL)** або **(lu, LU)**.

**Дійсні числа** у мовах програмування мають дві форми подання: десяткову (природну) та експоненціальну (показникову).

**Десяткова форма** дійсного числа — це звичайний десятковий формат запису дійсного числа, тільки частина дійсного числа відділяється від дробової крапкою, а не комою, наприклад 10.123, 1.0123, 1012.3, 0.0010123.

**Експоненціальна форма** дійсного числа використовується для запису дуже великих або дуже малих чисел, для яких за­давати зайві нулі не зовсім зручно, наприклад: 1 .0123*10<sup>20</sup>,1.0123*10<sup>-10</sup>. У цій формі запису числа можна виділити такi основні характеристики: знак числа, мантису числа, знак порядку та порядок числа. Зазначені характеристики дійсного числа зберігаються у пам’яті комп’ютера. Число у показнико­вій формі може бути представлено, наприклад, так: 1.0123Е-10\. Мантиса записується ліворуч від знака експоненти(**Е чи е**), порядок — праворуч. Символ **Е (е)** означає основу степеня 10, і компілятор розпізнає цей запис як форму представлення дійс­ного числа. Символ пропуску всередині числа не допускається, а для відділення цілої частини від дробової використовується не кома, а крапка. При додатних значеннях числа і мантиси знак «+» можна не вказувати.

Як десяткова, так і екcпоненціальна форми запису допуска­ють відсутність або цілої частини, або дробової, але не двох одразу.

За замовчуванням всі дійсні константи мають тип **double**— подвійну точність, що найчастіше займає в пам’яті 64 біти, тобтo 8 байтів. Але у випадку, якщо програміста не влаштовує тип за замовчуванням, його можна вказати явно за допомогою спе­ціальних літер. Так, додавши літеру **f чи F**, константі надають дійсний тип **float** зі звичайною точністю, наприклад, 8.5f. Якщо в представленні константи використовується літера **L чи l**, то вона має тип **long double**.

Зображення від’ємної цілої чи дійсної константи вважається константним виразом, що складається зі знака унарної операціi зміни знака (-) та константи, наприклад: -273, -2730.е-1, -273L.

**Символьні константи** мають один або два символи, що подаються в апострофах. Односимвольні константи займають у пам’яті один байт і мають стандартний тип **char** (**character-символ**). Двосимвольні константи займають два байти і мають тип **int**. Символьні константи мають цілий тип і їх можна ви­користовувати як цілочислові операнди у виразах.

Заслуговують уваги послідовності, що починаються зі знака «\», їх називають **керуючими** або **escape-п****ослідовностями.** Символ зворотної косої риски «\» використовується для запису кодів,що не мають графічного зображення, для запису симво­лiв, а також для виведення символьних констант, якщо їх коди заданi у вісімковому та шістнадцятковому вигляді (табл. 3.3).

Таблиця 3.3

**Керуючі послідовності мови С++**

<table border="0" width="664" cellspacing="0" cellpadding="0">

<tbody>

<tr>

<td valign="top" width="128">

\а

</td>

<td valign="top" width="535">звуковий сигнал</td>

</tr>

<tr>

<td valign="top" width="128">

\b

</td>

<td valign="top" width="535">повернення на крок</td>

</tr>

<tr>

<td valign="top" width="128">

\f

</td>

<td valign="top" width="535">переведення сторінки (формату)</td>

</tr>

<tr>

<td valign="top" width="128">

\n

</td>

<td valign="top" width="535">новий рядок</td>

</tr>

<tr>

<td valign="top" width="128">

\r

</td>

<td valign="top" width="535">повернення каретки</td>

</tr>

<tr>

<td valign="top" width="128">

\t

</td>

<td valign="top" width="535">горизонтальна табуляція</td>

</tr>

<tr>

<td valign="top" width="128">

\v

</td>

<td valign="top" width="535">вертикальна табуляція</td>

</tr>

<tr>

<td valign="top" width="128">

\\

</td>

<td valign="top" width="535">символ \ — зворотна коса риска</td>

</tr>

<tr>

<td valign="top" width="128">

\’

</td>

<td valign="top" width="535">символ ‘ — апостроф</td>

</tr>

<tr>

<td valign="top" width="128">

\”

</td>

<td valign="top" width="535">символ ” — лапки</td>

</tr>

<tr>

<td valign="top" width="128">

\0

</td>

<td valign="top" width="535">нуль-символ</td>

</tr>

<tr>

<td valign="top" width="128">

\?

</td>

<td valign="top" width="535">знак питання</td>

</tr>

<tr>

<td valign="top" width="128">

\0ddd

</td>

<td valign="top" width="535">вісімковий код символу</td>

</tr>

<tr>

<td valign="top" width="128">

\0xddd

</td>

<td valign="top" width="535">шістнадцятковий код символу</td>

</tr>

</tbody>

</table>

**Рядкова константа(рядковий літерал****)**— це послідовність cимволів,що подається в лапках (тобто в символах **«”»** )і збері­гаеться у неперервній ділянці пам’яті, наприклад: **Это строковый литерал”**. У кінець кожного рядкового літералу компілятором додається нуль-символ,що предствляється керуючою послі­довністю **«\0».**Тому довжина рядка завжди на одиницю більше кількості символів у його записі. Таким чином, порожній рядок (” ) має довжину 1 байт. Слід звернути увагу на різницю між рядком з одного символу, наприклад, С” і символьною конс­тантою ‘С’ . Порожня символьна константа неприпустима.

Керуючі послідовності можуть також застосовуватись у ряд­кових константах. Так, якщо всередині рядка потрібно записати лапки, то перед ними слід розташувати зворотну косу риску («\»), за якою компілятор відрізняє їх від лапок, що обмежують рядок:

**Книга имеет название \”Язык прогаммирования С++\” .**

Рядки,що записані у програмі підряд або через символи пропуску, при компіляції конкатенуються («склеюються»). Тоб­то послідовність двох рядків

<div>Уча других, мы учимся сами.”</div>

<div>**Успех —это успеть.”**</div>

цілком еквівалентна рядку:

**Уча других, мы учимся сами. Успех — это успеть.”.**

Довгу рядкову константу можна розмістити також на декількох рядках. У цьому випадку ставиться зворотна коса рис­ка і натискається клавіша **Enter**. Наприклад:

<div>Компьютерная программа выполняет то, \</div>

<div>**что вы ей приказали делать, а не то, \**</div>

<div>**что вы хотели, чтобы она делала.”**</div>

Поняття та приклади оголошення типізованої константи, тобто константи, що використовується як змінна, значення якoї не може бути змінене після ініціювання, розглянуті вище.

Існує інша можливість задання констант — з використан­ням директиви препроцесора **#define**,при цьому оголошення має вигляд:

```cpp
#define ім’я константи значення константи
```

і наприкінці такого запису символ **«;»** не ставиться, тобто:

<div>#define max 65532</div>

<div>**#define km 1000.**</div>

Директива **#define** визначає ідентифікатор (ім’я констан­ти) і послідовність символів (значення константи), яка замінює ідентифікатор у тексті програми.

**Нульовий покажчик** (NULL-покажчик)— єдина неарифме­тична константа мови C++.

При застосуванні великої кількості логічно взаємозалежних констант C++ доцільно користуватися константами перелічення. Тип перелічення має вигляди:

```cpp
enum {список іменованих констант}; // —н еiменоване перелічення,
enum [ім’я] {список іменованих констант}; // — iменоване перелічення.
```

де

**enum**—службове слово(**enumerate**—перелічувати);

**ім’я**— ім’я списку констант;

**список іменованих констант**— розділена комами послідов­нiсть iдентифікаторів або іменованих констант вигляду:

**ім’я константи = значення константи.**

Наприклад:

```cpp
enum {Anton, Ivan, Piter};
enum Months {January = 1, February, Marth, April, May, June, July, August, September, October, November, December};
```

Якщо значення константи перелічення не визначено, то воно на одиницю більше значення попередньої константи. За замовчуванням перша константа має значення **0**. Тоді у першому прикладі константи одержать значення:**Anton = 0, Ivan = 1, Piter = 2**, а у другому — значення: J**anuary = 1, February = 2, Marth= З** тощо. Іменовані перелічення задають унікальний цілочисловий тип і можуть використовуватися як специфікації типу для визначення змінних.

## Класи пам'яті і область дії
Класи пам'яті мови Сі дають можливість визначити, з якими функціями пов'язані якісь змінні, і як довго змінна зберігається в програмі. Ми вже згадували, що локальні змінні відомі тільки функцій, що містить їх. У мові Сі передбачається також, що про глобальних змінних знають відразу кілька функцій:
```cpp
/* глобальна змінна ext */
int ext; /* зовнушня змінна */
main( )
{
	extern int ext;
	printf("скільки курсів на сайті intuit.ru?\n");
	scanf("%d",&ext);
	while(ext != 30)
	critic( );
	printf("Перегляньте на сайті!\n");
}
critic( )
{
	extern int ext;
	printf("Помилка. Спробуйте знову.\n");
	scanf("%d",&ext);
}
```
  
Ми зробили змінну Ext зовнішньою, описавши її поза будь-якого визначення функції. Усередині функції, що використовує цю змінну, ми оголошуємо її зовнішньою за допомогою ключового слова extern, що передує специфікації типу змінної. Компілятор шукає визначення цієї змінної поза функцією. Якби ми опустили ключове слово extern в функції critic( ), то компілятор створив би в функції criticнову змінну і теж назвав би її Ext. Тоді інша змінна Ext, яка знаходиться в main( ), ніколи не отримала б нового значення.
Кожна змінна має тип і належить до певного класу пам'яті. Час життя і область дії ідентифікатора визначаються асоційованим з ним класом пам'яті. Існують чотири різновиди класів пам'яті:
auto - автоматичний - локальні ідентифікатори, пам'ять для яких виділяється при вході в блок, тобто складовийоператор, і звільняється при виході з блоку. Слово auto є скороченням слова automatic.
static - статистичний - локальні ідентифікатори, існуючі в процесі всіх виконань блоку. На відміну від ідентифікаторів типу auto, для ідентифікаторів типу static пам'ять виділяється тільки один раз - на початку виконання програми, і вони існують, поки програма виконується.
extern - зовнішній - ідентифікатори, які називаються зовнішніми, external, використовуються для зв'язку між функціями, в тому числі незалежно скомпільованими функціями, які можуть перебувати в різних файлах. Пам'ять, асоційована з цими ідентифікаторами, є постійною, однак її вміст може змінюватися. Ці ідентифікатори описуються поза функцією.
register - регістровий- ідентифікатори, подібні до ідентифікаторів типу auto. Їх значення, якщо це можливо, повинні поміщатися в регістрах машини для забезпечення швидкого доступу до даних.
Якщо клас пам'яті ідентифікатора не вказано явно, то його клас пам'яті задається положенням його визначення в тексті програми. Якщо ідентифікатор визначається всередині функції, тоді його клас пам'яті auto, в інших випадках ідентифікатор має клас пам'яті extern.
Припустимо, що є програма на мові Сі, вихідний текст якої міститься в декількох файлах. Для розділення даних (для зв'язку) у функціях в цих файлах використовуються ідентифікатори, визначені як extern. Якщо функція посилається на зовнішній ідентифікатор, то файл, який містить його, повинен мати опис або визначення цього ідентифікатора. Явне завдання класу пам'яті extern вказує на те, що цей ідентифікатор визначений в іншому файлі, і тут йому пам'ять не виділяється, а його опис дано лише для перевірки типу і для генерації коду.
!	При описі зовнішніх масивів максимальне значення першого індексу масиву вказувати немає необхідності. Воно буде отримано з відповідної ухвали, що створює додаткові зручності для користувача.
Для зовнішнього ідентифікатора пам'ять виділяється тільки в тому випадку, якщо клас пам'яті не вказано явно.
!	Явна вказівка пам'яті extern є відмітною ознакою зовнішнього опису від зовнішнього визначення.
Хоча опис зовнішнього ідентифікатора може зустрітися в багатьох файлах, тільки один файл повинен містити визначення зовнішнього ідентифікатора. Область дії зовнішніх ідентифікаторів не обмежується файлом, що містить їх визначення, а включає також файли з відповідними описами, з класом пам'яті extern.
Визначення класу пам'яті змінної залежить від того, де змінна описана і яке ключове слово, якщо воно є, використовується.
Клас пам'яті дозволяє встановити два факти. По-перше, визначити, які функції мають доступ до змінної. Межі, до яких змінна доступна, характеризують її область дії. По-друге, визначити, як довго змінна знаходиться в пам'яті. Тепер докладніше розглянемо властивості кожного типу.
Автоматичні змінні
За замовчуванням змінні, описані усередині функції, є автоматичними. Можна, однак, це підкреслити явно за допомогою ключового слова auto:
```cpp
main( ) 
{
	auto int kat;
}
```
Так надходять, якщо хочуть, наприклад, показати, що визначення змінної не потрібно шукати поза функцією.
Автоматичні змінні мають локальну область дії. Тільки функція, в якій змінна визначена, знає її. Інші функції можуть використовувати змінні з тим же самим ім'ям, але це будуть незалежні змінні, що знаходяться в різних осередках пам'яті.
Автоматична змінна починає існувати при виконанні функції, що містить її. Коли функція завершує свою роботу і повертає керування туди, звідки її викликали, автоматична змінна зникає. Область дії автоматичної змінної обмежена блоком, тобто {}, В якому змінна описана.
!	Ми завжди повинні описувати наші змінні на початку тіла функції (блоку). Областю дії їх є вся функція. Можна описати змінну всередині подблока. Тоді змінна буде відома тільки в цій частині функції, однак цього краще не робити. Це поганий стиль програмування!
Зовнешні змінні
Змінна, описана поза функцією, є зовнішньою.
Глобальні змінні визначаються на тому ж рівні, що і функції, тобто вони не локальні ні в якому блоці. Постійні глобальні змінні не започатковано нулем, якщо явно незадано інше початкове значення. Областю дії є вся програма. Вони повинні бути описані у всіх файлах програми, в яких до них є звернення. Деякі компілятори вимагають, щоб глобальні змінні були визначені тільки в одному файлі, і описані як зовнішні в інших файлах, де вони використовуються. Глобальні змінні повинні бути описані у файлі до першого використання.
Приклад:
int global_flag;
Зовнішню змінну можна описати і в функції, яка використовує її, за допомогою ключового слова extern. Групу extern - описів можна зовсім опустити, якщо вихідні визначення змінних з'являються в тому ж файлі і перед функцією, яка їх використовує. Включення ключового слова extern дозволяє функції використовувати зовнішню змінну, навіть якщо вона визначається пізніше в цьому або іншому файлі. Обидва файли повинні бути скомпільовані, пов'язані або зібрані в один і той же час.
Якщо слово extern не включене в опис всередині функції, то під цим ім'ям створюється нова автоматична змінна. Ми можемо помітити другу змінну як автоматичну за допомогою слова auto.
Статичні змінні
Статичні тут означає, що змінні залишаються в роботі. Вони мають таку ж область дії, як автоматичні змінні, але вони не зникають, коли містить їх функція закінчить свою роботу. Компілятор зберігає їх значення від одного виклику функції до іншого.
Приклад:
```cpp
/* Статична змінна */
main( )
{
	int count;
	for(count = 1;count <= 3; count ++)
	{
		printf("Підрахунок студентів %d:\n", count);
		man_woman ( );
	}
}
man_woman( )
{
	int man = 1;
	static int woman = 1;
	printf("юнаків = %d та дівчат = %d\n", 
		man++, woman++);
}
```
Функція man_woman збільшує кожну змінну після друку її значення. Робота цієї програми дає наступні результати:
Підрахунок студентів 1:
юнаків = 1 и дівчат = 1
Підрахунок студентів 2:
юнаків = 1 и дівчат = 2
Підрахунок студентів 3:
юнаків = 1 и дівчат = 3
Статична змінна woman пам'ятає, що її значення було збільшено на 1, в той час як для змінної man початкове значення встановлюється кожного разу заново. Це вказує на різницю в ініціалізації: man инициализируется кожен раз, коли викликається man_woman ( ), в той час як woman инициализируется тільки один раз при компіляції функції man_woman ( ).
Зовнішні статичні змінні
Можна описати статичні змінні поза будь-якої функції. Це створює зовнішню статичну змінну. Різниця між зовнішньою змінною і зовнішньої статичною змінною полягає в області їх дії. Звичайна зовнішня змінна може використовуватися функціями в будь-якому файлі, а зовнішня статична змінна може використовуватися тільки функціями того ж самого файлу, причому після визначення змінної. Статичну змінну ми описуємо поза будь-якої функції.
реєстрові змінні
Зазвичай змінні зберігаються в пам'яті машини. Реєстрові змінні запам'ятовуються в регістрах центрального процесора, де доступ до них і робота з ними виконуються набагато швидше, ніж в пам'яті. В іншому реєстрові змінні аналогічні автоматичним змінним.
Приклад:
```cpp
main( )
{
	register int pleat;
}
```
Компілятор порівнює наші вимоги до кількості доступних регістрів, тому ми можемо і не отримати те, що хочемо. У цьому випадку змінна стає простий автоматичної змінної.
Особливості роботі з мовою СІ. Який клас пам'яті застосовувати? Відповідь на питання - автоматичний. Цей клас пам'яті обраний за замовчуванням. Використання зовнішніх змінних дуже спокусливо. Якщо описати всі змінні як зовнішні, то не буде турбот при використанні аргументів і покажчиків для зв'язку між функціями в прямому і зворотному напрямках. Але тоді виникає проблема з функцією С, змінює змінні в функції А, а ми цього не хотіли! Така проблема значно переважує гадану привабливість широкого використання зовнішніх змінних. Одне із золотих правил програмування полягає в дотриманні принципу "необхідно знати тільки те, що потрібно". Організуйте роботу кожної функції автономно, наскільки це можливо, і використовуйте глобальні змінні тільки тоді, коли це дійсно необхідно!
Операція отримання адреси & непридатна до реєстрових змінних. Будь-які змінні в блоці, крім формальних параметрів функції, можуть бути визначені як статичні.
Підіб’ємо підсумки.
Класи пам'яті, які описуються всередині функції:
1.	автоматичний, тривалість існування - тимчасово, область дії - локальна;
2.	регістровий, тривалість існування - тимчасово, область дії - локальна;
3.	статичний, тривалість існування - постійно, область дії - локальна.
Класи пам'яті, які визначаються поза функцією:
1.	зовнішній, тривалість існування - постійно, область дії глобальна (всі файли);
2.	зовнішній статичний, тривалість існування - постійно, область дії - глобальна (один файл).


## Вирази
Вираз являє собою об'єднання операцій і операндів. Нагадаємо, що операндом називається те, над чим виконується операція. Найпростіший вираз складається з одного операнда. Спираючись на це поняття виразу, ми можемо будувати більш складні конструкції. Наведемо кілька виразів:
100
1904+100
a*(c-d)
x=0
x=y++
x>3
Виразами називаються компоненти програми, складені з використанням операцій, литералов, констант, змінних (включаючи масиви, структури та об'єднання) і викликів функцій. Порядок обчислення виразів визначено лише вимогами відповідності семантиці операторів і дотримання правил пріоритету і порядку виконання операцій. При виконанні цих вимог компілятор вільний у виборі порядку обчислення виразу, навіть якщо обчислення підвиражень може призвести до побічних ефектів.
На відміну від більшості інших мов, в мові Сі для завдання певного порядку обчислення виразу недостатньо тільки відповідної розстановки дужок, так як компілятор може довільно змінювати порядок вираження, що включають асоціативні і комутативні оператори (*, +, |, ^) навіть при наявності дужок. Для завдання бажаного порядку виконання виразу потрібно використовувати додаткові привласнення, якщо потрібно, з використанням тимчасових змінних.
Необхідно з обережністю використовувати вирази, при обчисленні яких можливі побічні результати, так як результати обчислення таких виразів часто проявляються не відразу і, крім того, залежать від використовуваного компілятора. Наприклад, в результаті обчислення операторів присвоювання
j=3;
i=(k=j+1)+(j=5);
значення змінної i дорівнюватиме 9 або 11 в залежності від того, який підвираз другої операції буде обчислено першим. Таким чином, з використанням різних компіляторів можна отримати різні результати.

### Найпрстіші вирази
Найпростішими виразами називаються вирази, сформовані з використанням констант типів int, char і enum, операції sizeof, унарних операторів - і ~, бінарних операторів + * /% & | ^ << >> = =! = <> <=> =  і тернарної операції?:.
Найпростіші вирази використовуються в операторі switch, в ініціалізаторах кордонів масивів і в операторі препроцесора #if.



## Контрольні запитання

1.  Які основні та складені типи даних має мова С++?
2.  Що таке змінна і як здійснюється її опис та визначення?
3.  Що таке «область дії ідентифікатора» та «клас пам’яті»?
4.  Які константи налічує С++? Охарактеризуйте їх застосування
5.  Що таке пріоритет операції? Наведіть приклади арифметичниx та логічних операцій
6.  Які операції присвоювання та операції відношення налічує С++?
7.  Що реалізують логічні операції та операції обробки окремих бітів?
8.  Які операції над покажчиками та додаткові операції має С++?