# Обробка файлів ч.3. Функції WinAPI

[Перелік лекцій](README.md)

## Загальні відомості

WinAPI (Windows API) - це набір функцій і інтерфейсів програмування, що надаються операційною системою Windows для розробки додатків для цієї платформи.

Основні можливості WinAPI включають:

1. Керування вікнами та ресурсами: WinAPI надає можливості для створення вікон, керування їх властивостями (розмір, положення, стиль тощо) та взаємодії з користувачем за допомогою різних контролів, таких як кнопки, поле введення тощо.

2. Робота з файлами і директоріями: WinAPI надає можливості для створення, відкриття, закриття, копіювання, переміщення, видалення файлів та директорій, а також для роботи зі шляхами до файлів.

3. Мережеве програмування: WinAPI дозволяє створювати програми, які взаємодіють з мережею, включаючи можливість створення мережевих з'єднань, передачі даних, з'єднання з серверами тощо.

4. Робота зі системними ресурсами: WinAPI надає можливості для керування системними ресурсами, такими як реєстр Windows, служби Windows, процеси і потоки, пристрої вводу/виводу тощо.

5. Графіка та зображення: WinAPI дозволяє створювати графічні елементи і обробляти зображення, включаючи можливості створення малюнків, зображень, зображень з прозорістю, а також робота з форматами зображень (BMP, JPEG, PNG тощо).

6. Криптографія та безпека: WinAPI надає можливості для криптографічного захисту даних, включаючи можливості для шифрування, розшифрування, хешування, підписування та перевірки цифрових підписів, а також для роботи з сертифікатами безпеки.

7. Міжпроцесова взаємодія: WinAPI дозволяє створювати програми, які взаємодіють між собою через міжпроцесову взаємодію, включаючи можливості для створення іменованих каналів, сокетів, повідомлень тощо.

8. Мультипоточність: WinAPI дозволяє створювати програми з мультипоточним виконанням, включаючи можливості для створення потоків, синхронізації доступу до ресурсів, забезпечення безпеки виконання тощо.

9. Звук та мультимедіа: WinAPI дозволяє створювати програми, які взаємодіють зі звуком та мультимедіа, включаючи можливості для відтворення аудіо та відео, керування звуковими пристроями, захоплення відео тощо.

10. Взаємодія з іншими сервісами та додатками: WinAPI надає можливості для взаємодії з іншими сервісами та додатками, включаючи можливості для роботи зі скриншотами, віртуальною клавіатурою, системними подіями та повідомленнями, друком документів тощо.

## Хендли

Хендл (англ. handle) - це ідентифікатор об'єкта в операційній системі, який використовується для керування ресурсами, такими як файли, процеси, потоки, канали зв'язку тощо.

Хендл можна розглядати як вказівник на об'єкт, хоча насправді він може бути будь-яким цілочисельним значенням, яке є унікальним у межах процесу, який створив об'єкт.

Хендли дозволяють процесу отримувати доступ до ресурсу операційної системи, а також виконувати з ним певні операції, такі як читання або запис до файлу, керування процесами, створення та очікування потоків тощо.

Кожен тип об'єктів в операційній системі має свій унікальний тип хендла, наприклад, HANDLE для файлів та процесів у Windows, і file descriptor в Unix-подібних системах. Важливо знати, що хендли дійсні тільки в контексті процесу, який їх створив, і не можуть бути використані іншими процесами.

## WinAPI і робота з файлами

WinAPI містить декілька функцій для роботи з файлами, основні з яких:

1. **CreateFile**: функція створює або відкриває файл і повертає дескриптор файлу, який потім може використовуватися для доступу до файлу.

2. **ReadFile**: функція читає дані з файлу в буфер.

3. **WriteFile**: функція записує дані з буфера в файл.

4. **SetFilePointer**: функція встановлює позицію файлу, яка використовується для наступних операцій зчитування або запису.

5. **GetFileSize**: функція повертає розмір файлу в байтах.

6. **CloseHandle**: функція закриває дескриптор файлу.

7. **DeleteFile**: функція видаляє файл з файлової системи.

8. **MoveFile**: функція переміщує або перейменовує файл.

9. **CopyFile**: функція копіює файл.

10. **GetFileAttributes**: функція повертає атрибути файлу, такі як режим доступу, час створення, час модифікації тощо.

11. **FindFirstFile** і **FindNextFile**: функції використовуються для пошуку файлів у директорії за допомогою маски імені файлу.

Ці функції дозволяють програмістам створювати, читати, записувати, переміщувати, перейменовувати та видаляти файли, а також отримувати інформацію про них. Завдяки WinAPI можна працювати з різними типами файлів, включаючи текстові файли, бінарні файли, файли зображень тощо.

### Відкриття та створення файлів

Для створення нового або відкриття існуючого файлу використовується функція CreateFile. При використанні функції CreateFile необхідно вказати, чи передбачається читання або запис в файл, або і те, і інше. Також необхідно вказати необхідні дії у випадку наявності або відсутності файлу на диску (наприклад, перезаписувати файл, якщо він існує, і створювати новий, якщо його немає). Функція CreateFile також дозволяє вказати можливість розподілу файлу з іншими додатками (одночасного читання/запису декількох додатків в файл). Якщо деякий додаток монополізував доступ до файлу на читання і/або запис, то жоден інший додаток не зможе читати і/або записувати в файл, поки перше його не закриє.

Операційна система присвоює кожному відкритому файлу унікальний ідентифікатор (дескриптор, file handle), який може бути використаний при зверненнях до файлу для запису, читання та отримання інформації про файл. Дескриптор дійсний до тих пір, поки файл не закритий. Додаток може успадковувати дескриптори файлів від процесу, який його запустив (якщо дескриптори успадковувані).

Функція CreateFile серед інших об'єктів дозволяє звертатися до файлів і каналів (pipes). При зверненні до каналів функція CreateFile дозволяє створювати клієнтське підключення до іменованих каналів, що перебувають в режимі очікування підключення. Серверна частина каналу створюється функцією CreateNamedPipe. Одне додаток може створювати безліч клієнтських підключень до каналу, але до одного екземпляру каналу може підключитись лише одне застосування (Варто відзначити, що можливе існування кількох екземплярів іменованих каналів з однаковими іменами).


Функція **CreateFile** має наступний прототип:

```cpp
HANDLE CreateFile(
  LPCTSTR lpFileName, // file name
  DWORD dwDesiredAccess, // access mode
  DWORD dwShareMode, // share mode
  LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
  DWORD dwCreationDisposition, // how to create
  DWORD dwFlagsAndAttributes, // file attributes
  HANDLE hTemplateFile // handle to template file
);
```

Параметри:

- lpFileName:
[in] Вказівник на рядок, що містить ім'я об'єкта для створення або відкриття (ім'я файлу, шлях до файлу, ім'я каналу тощо). Якщо ім'я задається літеральною константою, то слід помістити її в макрос TEXT() або поставити L перед відкриваючою лапкою. Наприклад, TEXT("C:\tmp.txt") або L"C:\tmp.txt"

- dwDesiredAccess:
[in] Опис бажаного режиму доступу до файлу. Існує можливість передачі великої кількості різних прапорців. Нас цікавлять прапорці GENERIC_READ, GENERIC_WRITE та їх об'єднання. При доступі до каналів слід враховувати режим створення каналу сервером. Якщо сервер створив канал для запису, то клієнт відкриває його для читання, і навпаки. Якщо сервер створив канал для читання і запису, то клієнт може відкрити його як для читання, так і для запису.

- dwShareMode:
[in] Визначає режим розподілу об'єкта.
0 – додаток відкриває файл для монопольного доступу. Подальші звернення на відкриття даного файлу будуть невдалими, поки даний дескриптор не буде закритий. Для розподілу доступу до файлу можуть використовуватися наступні ключі (один або разом):
FILE_SHARE_READ – дозволені лише наступні операції відкриття лише на читання.
FILE_SHARE_WRITE – дозволені лише наступні операції відкриття лише на запис.

- lpSecurityAttributes:
[in] Вказівник на структуру SECURITY_ATTRIBUTES, яка визначає можливість успадкування дескриптора дочірніми процесами. Можна передавати NULL - це означає, що дескриптор не може бути успадкований (для наших додатків цього достатньо).

- dwCreationDisposition:
[in] Визначає, які дії необхідно вжити у випадках, якщо файл існує і якщо файл не існує. Цей параметр повинен мати одне з наступних значень:
    - CREATE_NEW Створює файл. Виклик закінчується невдачею, якщо файл існує.
    - CREATE_ALWAYS Створює новий файл. Якщо файл існує, то його вміст і атрибути будуть стерті.
    - OPEN_EXISTING Відкриття файлу. Якщо файл не існує, то виклик закінчиться невдачею.
    - OPEN_ALWAYS Відкриває файл. Якщо файл не існує, то він буде створений.
    - TRUNCATE_EXISTING Відкриває файл, розмір якого обнуляється. Файл повинен відкриватися як мінімум з режимом доступу GENERIC_WRITE. Якщо файл не існує, то виклик буде невдалим.

- dwFlagsAndAttributes:
[in] Дозволяє задавати файлові атрибути (тільки для читання, прихований, системний і т.д.). Також дозволяє повідомляти операційній системі бажану поведінку при роботі з файлами. Наприклад, запис до файлу без буферизації (FILE_FLAG_NO_BUFFERING і FILE_FLAG_WRITE_THROUGH); оптимізація для неупорядкованого доступу (FILE_FLAG_RANDOM_ACCESS); відкриття для асинхронного введення/виведення (FILE_FLAG_OVERLAPPED).

Повернене значення:

Якщо виклик вдалий, повертається дескриптор відкритого файлу. Якщо виклик не вдалий, повертається константа INVALID_HANDLE_VALUE. Код помилки можна отримати за допомогою функції GetLastError. Детальну інформацію про помилку (за її кодом) можна отримати за допомогою функції FormatMessage.

### Читання та запис у файл

Кожен відкритий файл має файловий вказівник (file pointer), який вказує на позицію наступного байту, який буде записаний/прочитаний. При відкритті файлу його файловий вказівник переміщується на початок файлу. Після прочитання/запису наступного байту, файловий вказівник автоматично зсувається. Файловий вказівник можна переміщувати за допомогою функції SetFilePointer.
Для читання/запису до файлу використовуються функції ReadFile та WriteFile, причому файл має бути відкритий на читання або запис відповідно.

Функція **ReadFile** читає з файлу задану кількість символів, починаючи з позиції, вказаної файловим вказівником. При синхронному (на відміну від асинхронного) читанні файловий вказівник зсувається на фактично прочитану кількість байтів.

```cpp
BOOL ReadFile(
HANDLE hFile, // дескриптор файлу
LPVOID lpBuffer, // буфер даних
DWORD nNumberOfBytesToRead, // кількість байтів для читання
LPDWORD lpNumberOfBytesRead, // кількість фактично прочитаних байтів
LPOVERLAPPED lpOverlapped // вказівник на структуру, використовувану при
// асинхронному читанні
);
```

Параметри:

- hFile:
[in] Дескриптор записуваного файлу. Повинен бути відкритий з доступом GENERIC_WRITE.

- lpBuffer:
[in] Вказівник на буфер, що містить дані для запису в файл.

- nNumberOfBytesToWrite:
[in] Визначає кількість байтів, які потрібно записати в файл.

- lpNumberOfBytesWritten:
[out] Вказівник на змінну, що містить кількість фактично записаних байт.

- lpOverlapped:
[in] Вказівник на структуру OVERLAPPED. При неасинхронному доступі слід передавати NULL.

Повертає значення:

Якщо виконання функції пройшло успішно, то повертається ненульове значення. Якщо повернуто ненульове значення, але записано 0 байтів, то файловий вказівник стояв на кінці файлу перед операцією запису.


Функція **WriteFile** записує дані до файлу, починаючи з позиції, вказаної файловим вказівником. При синхронній (на відміну від асинхронної) записі файловий вказівник зсувається на фактично записану кількість байт.

```cpp
BOOL WriteFile(
HANDLE hFile, // дескриптор файлу
LPCVOID lpBuffer, // буфер даних
DWORD nNumberOfBytesToWrite, // кількість байт для запису
LPDWORD lpNumberOfBytesWritten,// кількість фактично записаних байт
LPOVERLAPPED lpOverlapped // вказівник на структуру, яка використовується при
// асинхронному читанні
);
```
Параметри:

- hFile:
[in] Дескриптор файлу, до якого відбувається запис. Повинен бути відкритий з доступом GENERIC_WRITE.

- lpBuffer:
[in] Вказівник на буфер, що містить дані, які необхідно записати.

- nNumberOfBytesToWrite:
[in] Визначає кількість байтів, які необхідно записати до файлу.

- lpNumberOfBytesWritten:
[out] Вказівник на змінну, яка приймає кількість фактично записаних байтів.

- lpOverlapped:
[in] Вказівник на структуру OVERLAPPED. При не асинхронному доступі слід передавати NULL.

Повернення:
Якщо функція виконалась успішно, то повертається ненульове значення.

### Блокування файлів

Оскільки система дозволяє декільком додаткам одночасно відкривати файл та записувати до нього, додатки не повинні одночасно записувати до одного регіону файлу. Цю проблему можна вирішити шляхом тимчасового блокування частини файлу. Функція LockFile дозволяє додатку отримати монопольний доступ до певної кількості байтів у файлі. Блок заблокованих байтів може виходити за поточний кінець файлу. Будь-які спроби сторонніх додатків звернутися до заблокованої частини файлу будуть невдалими.
Додаток може розблокувати файл за допомогою функції UnlockFile.

```cpp
BOOL LockFile(
HANDLE hFile, // дескриптор файлу
DWORD dwFileOffsetLow, // менші двійкові розряди зміщення початку блоку
DWORD dwFileOffsetHigh, // старші двійкові розряди зміщення початку блоку
DWORD nNumberOfBytesToLockLow, // менші двійкові розряди довжини блоку
DWORD nNumberOfBytesToLockHigh // старші двійкові розряди довжини блоку
);
```
Параметри:

- hFile:
[in] Дескриптор файлу, у який відбувається запис. Має бути відкритий з доступом GENERIC_READ або GENERIC_WRITE (або обома).

- dwFileOffsetLow:
[in] Визначає менші двійкові розряди зміщення початку блоку, який блокується, відносно початку файлу.

- dwFileOffsetHigh:
[in] Визначає старші двійкові розряди зміщення початку блоку, який блокується, відносно початку файлу. Не є нулем, якщо зміщення відносно початку більше 232 байт.

- nNumberOfBytesToLockLow:
[in] Визначає менші двійкові розряди довжини блоку, який блокується.

- nNumberOfBytesToLockHigh:
[in] Визначає старше слово довжини блокованого відрізка. Не дорівнює нулю, якщо довжина відрізка більше 232 байтів або 4 ГБ.

Повертає значення:

Якщо функція виконалася успішно, то повертається ненульове значення.
Блокування надає процесу монопольний доступ до відрізка файлу. Файлові блокування не успадковуються. Інші процеси не можуть ні читати, ні записувати в заблоковану частину файлу.

Функція **UnlockFile** дозволяє розблокувати відрізок файлу, раніше заблокований функцією LockFile.
```cpp
BOOL UnlockFile(
HANDLE hFile, // дескриптор файлу
DWORD dwFileOffsetLow, // молодше слово зсуву початку відрізка
DWORD dwFileOffsetHigh, // старше слово зсуву початку відрізка
DWORD nNumberOfBytesToUnlockLow, // молодше слово довжини відрізка
DWORD nNumberOfBytesToUnlockHigh // старше слово довжини відрізка
);
```
Параметри даної функції аналогічні параметрам функції LockFile.

Повертає значення:

Якщо функція виконалася успішно, то повертається ненульове значення.
Відрізок файлу, який розблоковується функцією UnlockFile, повинен точно відповідати відрізку, заблокованому функцією LockFile. Наприклад, дві сусідні частини файлу не можуть бути заблоковані окремо і розблоковані як одне ціле. Процес не повинен завершувати виконання, маючи заблоковані частини файлів. Файловий дескриптор, для якого є заблоковані відрізки, не повинен закриватися.

### Закриття хендлу

Щоб оптимально використовувати ресурси операційної системи, додаток повинен закривати непотрібні файли за допомогою функції CloseHandle. Файли, які були відкриті на момент завершення додатку, автоматично закриваються.
```cpp
BOOL CloseHandle(
HANDLE hObject // Дескриптор об'єкта (файлу, каналу тощо)
);
```
Якщо виконання функції пройшло успішно, то повертається ненульове значення.

### Копіювання, переміщення та видалення файлів

Для копіювання файлів використовується функція **CopyFile**:

```cpp
BOOL CopyFile(
LPCTSTR lpExistingFileName, // ім'я існуючого файлу
LPCTSTR lpNewFileName, // ім'я нового файлу
BOOL bFailIfExists // дія, якщо файл існує TRUE – помилка
// FALSE - перезаписувати
);
```
У разі успішного виконання функції повертається ненульове значення.

Для перейменування файлів та каталогів використовується функція **MoveFile**:
```cpp
BOOL MoveFile(
LPCTSTR lpExistingFileName, // ім'я файлу
LPCTSTR lpNewFileName // нове ім'я файлу
);
```
У разі успішного виконання функції повертається ненульове значення.

Для видалення існуючих файлів використовується функція **DeleteFile**:
```cpp
BOOL DeleteFile(
LPCTSTR lpFileName // ім'я видаляємого файлу
);
```
У разі успішного виконання функції повертається ненульове значення.