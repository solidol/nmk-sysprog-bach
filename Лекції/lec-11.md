# Цикли ч.2

[Перелік лекцій](README.md)

## Цикл з лічильником
Оператор циклу for
`for(e1; e2; e3) s`

є зручним скороченим записом для циклу while виду
```cpp
e1;
while(e2) {
	s;
	e3;
}
```
Вираз e1 служить для задання початкових умов виконання циклу, вираз e2 забезпечує перевірку умови виходу з циклу, а вираз e3 модифікує умови, задані виразом e1. Будь-який з виразів e1, e2, e3 може бути опущено. Якщо опущено e2, то за замовчуванням замість нього підставляється значення TRUE. Наприклад, цикл for

for(;e2;) s;

з опущеними e1, e3 эквивалентен циклу

while(e2) s;

Цикл

for(;;) s;

з усіма опущеними виразами еквівалентний циклу

while(TRUE) s;

тобто еквівалентний нескінченному циклу. Такий цикл може бути перерваний тільки явним виходом з нього за допомогою операторів break, goto, return, що містяться в тілі циклу s.

Незважаючи на зовнішню схожість з ітеративними циклами for мов Паскаль і Ада або ітеративними циклами do мов Фортран або ПЛ / 1, цикл for мови Сі не є їх семантичної копією. Цикл for мови Сі має більшу спільністю, ніж цикли for і do інших мов. На відміну від цих циклів, в загальному випадку число ітерацій в циклі for мови Сі не може бути визначено до виконання цього циклу. continue

Цикл for і його альтернатива цикл while семантично майже еквівалентні, але, як вказується в роботі (Ritchie, D.M. 1980. The Programming Language - Reference Manual /. AT & T Bell Laboratories, Murray Hill, N.J. 07974), не ідентичні. Наприклад, розглянемо випадок, коли оператор s є оператором continue або складеним оператором, що містить оператор continue. Дія оператора continue полягає в переході до кінця циклу, що має різні наслідки для циклу for і його еквівалента у формі циклу while. У випадку з циклом for вираз e3 виконується до обчислення значення виразу e2, в той час як в еквівалентному циклі while вираз e3 пропускається.

Гнучкість конструкції for - наслідок способу використання виразів в специфікації циклу. До сих пір перший вираз застосовувалося для ініціалізації лічильника, друге - для завдання його граничного значення, а третє - для збільшення його поточного значення на 1. Але крім цієї можливості існує ще й багато інших можливостей його застосування, дев'ять з яких ми наведемо нижче.

Можна застосовувати операцію зменшення для рахунку в порядку убування замість рахунку в порядку зростання:
```cpp
for(n=10; n>0; n--)
printf("%d секунд!\n",n);
printf("Пуск! \n");
```
При бажанні можна вести рахунок двійками, десятками і т.д.:
```cpp
for (n=2; n<60;n=n+13);
printf("%d\n",n);
```
Можна вести підрахунок за допомогою символів, а не тільки чисел:
```cpp
for(ch = 'a';ch<='z';ch++)
printf("Величина коду ASCII для %с дорівнює %d.\n",ch,ch);
```
При виконанні цього оператора будуть виведені на друк всі букви від а до z разом з їх кодами ASCII. Цей оператор працює, оскільки символи в пам'яті машини розміщуються в вигляді чисел, і тому в даному фрагменті ведеться рахунок з використанням цілих чисел.

Можна перевірити виконання деякої довільної умови, відмінної від умови, що накладається на число ітерацій. Розглянемо приклад в програмі що друкує таблицю кубів цілих чисел:
```cpp
/* табліця кубів */
main( )
{
int num;
for(num=1; num<=6; num++)
printf("%5d %5d\n", num,num*num*num);
}
```
А тепер замінимо специфікацію
`for(num=1; num<=6; num++)`
на
`for(num=1; num<6; num++)`
Це було б доцільно в разі, якби нас більше займало обмеження максимального значення діапазону кубів чисел, а не кількість ітерацій.

Можна зробити так, щоб значення деякої величини зростала в геометричній, а не в арифметичній прогресії, тобто замість додавання фіксованого значення на кожному кроці циклу виконувалося б множення:

for(x=100.0; x<150.0; x=x*1.1)
printf("Ваш долг теперь %3.2f.\n",x);

У цьому фрагменті програми значення змінної x множиться на 1.1 на кожному кроці циклу, що збільшує її на 10%. Результат виглядає наступним чином:

Ваш долг теперь 100.00.
Ваш долг теперь 110.00.
Ваш долг теперь 121.00.
Ваш долг теперь 133.10.
Ваш долг теперь 146.41.

У якості третього вираження можна використовувати будь-який правильно складений вираз. Який б вираз ми не вказали, його значення буде змінюватися при кожній ітерації:

for (x=y=1; y<=75; y=5*x++)
printf("%10d %10d\n",x,y);

Зверніть увагу, що в специфікації циклу перевіряється значення y, а не x. У кожному з трьох виразів, які керують роботою циклу for, можуть використовуватися будь-які змінні.

Хоча цей приклад і правильний, він не може служити ілюстрацією хорошого стилю програмування. Програма виглядала б набагато зрозуміліше, якби ми не змішали процес зміни змінної циклу з алгебраїчними обчисленнями.

Можна навіть опустити одне або більше виразів, але при цьому не можна опустити символи "крапка з комою". тіло циклу
```cpp
for(;;) {
	...
}
```
буде виконуватися нескінченну кількість разів, оскільки пуста умова завжди вважається дійсною.
Перший вираз не обов'язково має ініціювати змінну. Замість цього, наприклад, там міг би стояти оператор printf( ). Необхідно пам'ятати тільки, що перший вираз обчислюється тільки один раз перед тим, як інші частини циклу почнуть виконуватися.

for(printf("Запам’ятовуй числа! \n"); num != 6;)
scanf("%d",&num);
printf("Це як раз те, чогоя хочу!\n");

У цьому фрагменті перше повідомлення виявляється виведеним на друк один раз, а потім здійснюється прийом чисел, що вводяться до тих пір, поки не надійде число 6.

Параметри, що входять до виразу, що знаходяться в специфікації циклу, можна змінити при виконанні операцій в тілі циклу. Припустимо, наприклад, що у вас є цикл зі специфікацією такого вигляду:

for(n=1; n<1000; n+t)

І якщо після декількох ітерацій наша програма вирішує, що величина t занадто мала або велика, то оператор if всередині циклу може змінити значення параметра. У діалогової програми користувач може змінити цей параметр в процесі виконання циклу. for

Рідведемо підсумки. В операторі for використовуються три вирази, що керують роботою циклу. Вони розділені символом "крапка з комою". Ініціалізуючий вираз обчислюється тільки один раз до початку виконання якого-небудь з операторів циклу. Якщо вираз що перевіряється виявляється істинним, або не рівним нулю, тіло циклу виконується один раз. Потім обчислюється величина корегуємого виразу, і значення виразу що перевіряється визначається знову.

Оператор for - це цикл з передумовою. Рішення про те, чи виконати в черговий раз тіло циклу чи ні, приймається до початку його проходження. Тому може статися так, що тіло циклу не буде виконано жодного разу. Оператор, який утворює тіло циклу, може бути як простим, так і складеним.

Операція "кома" збільшує гнучкість використання циклу for, дозволяючи включити в його специфікацію кілька ініціюючих або коригувальних виразів.

## Інші керуючі оператори
Оператори, що визначають циклічні обчислення, які ми розглянули, і умовні оператори if, if-else і switch, є найважливішими засобами управління виконанням програми на мові Сі. Вони повинні використовуватися для реалізації загальної структури програми. Три оператора, що розглядаються нижче, зазвичай розглядаються рідше, оскільки занадто часте їх використання погіршує читаність програми, збільшує ймовірність помилок і ускладнює її модифікацію. Ніклаус Вірт дав визначення структурного програмування, як програмування без goto.
Оператор break
Оператор break викристовується для виходу з операторів while, do, for, switch, що безпосередньо його містить. Управління передається на оператор, наступний за оператором, з якого здійснено вихід. Оператор break має форму
break;
Приклад:
```cpp
while((ch=getchar()) != EOF) 
/* читаєтся символ ch=getchar(). Якщо він не співпадає з  EOF, виконується тіло  оператора while */
{
	if(ch=='\n')
	break; 
	putchar(ch);
}
```
Робота циклу повністю припиняється, як тільки при введенні зустрічається символ "новий рядок".

Оператор continue

Оператор continue служить для пропуска решти виконуваної ітерації циклу, що його містить. Якщо умовами циклу допускається нова ітерація, то вона виконується, в іншому випадку цикл завершується. Оператор continue має наступну форму:
continue;
Пример:
```cpp
while((ch=getchar()) != EOF) 
/* читается символ ch=getchar(). Якщо він не співпадає з EOF, виконується тіло  оператора while */
{
	if(ch=='\n')
	continue;
	putchar(ch);
}
```
В версії з оператором continue просто пропускаються символи "новий рядок", а вихід з циклу відбувається, тільки коли читається ознака EOF.

Оператор goto

Оператор goto призначений для безумовної передачі керування до оператора з вказаною міткою. Він має наступну форму:
goto метка;

Керниган і Рітчі вважають оператор goto "Надзвичайно поганим" засобом і пропонують застосовувати його як можна рідше або не застосовувати зовсім. Наведемо приклад запису оператора:
goto part1;

Щоб цей оператор виконувався правильно, необхідна наявність іншого оператора, що має мітку part1. У цьому випадку запис оператора починається з мітки, за якою слідує двокрапка:
part1: printf("точка переходу\n");

Уникайте використовувати goto! З тих пір як Дейкстра опублікував свою знамениту працю "Шкідливість оператора GOTO", фахівці билися над методами структурного програмування. Повний опис структурного програмування виходить за рамки цього курсу лекцій, проте відзначимо, що потрібно дуже обережно використовувати оператори: goto, break, continue, return.

Якщо без операторів  goto, break, continue, return ніяк не обійтись , то при використанні goto переходьте вперед по коду, а не назад.

Оператор break краще не використовувати для передчасного виходу з циклу, його корисно використовувати всередині оператора switch.

Оператор continue небажано використовувати для модифікації логіки циклів.

Чому небажано використовувати функції з багатьма операторами return. Один із принципів структурного програмування полягає в тому, що програма повинна мати одну точку входу і одну точку виходу. Функції з багатьма операторами return більш складні для читання, ніж ті, які мають лише один оператор return в кінці тіла функції.

## Контрольні питання

1. Що таке цикл for у C++?
2. Які складові має конструкція циклу for в C++?
3. Які типи даних можна використовувати у якості індексів в циклі for?
4. Чи можна змінювати значення індексу під час виконання циклу for?
5. Які практичні приклади використання циклу for в C++?
6. Як можна використовувати двовимірні масиви в циклі for?
7. Як можна перебрати символи у рядку за допомогою циклу for?
8. Як можна перебрати елементи вектора за допомогою циклу for?
9. Чи можна вкладати один цикл for в інший цикл for?
10. Які змінні можуть бути оголошені в умові циклу for?
11. Як можна виконати цикл for задану кількість разів без використання індексу?
12. Чи можна використовувати булеві вирази умови циклу for?
13. Як можна зупинити виконання циклу for передчасно?
14. Як можна перейти до наступної ітерації циклу for без виконання поточної ітерації?
15. Які помилки можуть виникати при використанні циклу for в C++?