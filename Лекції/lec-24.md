# Наслідування

[Перелік лекцій](README.md)

## Узагальнено

**Наслідування** (inheritance) - це механізм побудови класу, відносно близького концептуально, на основі іншого. Цей механізм є одним з фундаментальних принципів ООП (об'єктно-орієнтованого програмування).

У загальному розумінні наслідування - це процес створення нового об'єкту, заснованого на вже існуючому об'єкті. У програмуванні наслідування використовується для створення нового класу, що має спільні властивості з вже існуючим класом (батьківським класом).

Коли клас успадковує інший клас, він отримує всі його властивості та можливості, включаючи методи, поля та константи. В цьому випадку клас, який успадковується, називається підкласом або нащадком, а клас, від якого успадковування відбувається, називається батьківським класом або суперкласом. Підклас може додати до свого батьківського класу нові властивості, методи або перевизначити вже існуючі.

Один з головних принципів ООП полягає в тому, що класи можуть бути організовані в ієрархію, де підкласи успадковують властивості та методи від батьківських класів, що дозволяє створювати більш складні ієрархії класів з підвищеним рівнем абстракції та гнучкістю.

Приклади реалізації концептуально близьких класів без використання наслідування та з ним:

```cpp
class Person
{
public:
    void print() const
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
    std::string name;       
    unsigned age;     
};
class Employee
{
public:
    void print() const
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
    std::string name;    
    unsigned age;       
    std::string company;   
};
```

```cpp
class Person
{
public:
    void print() const
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
    std::string name;       
    unsigned age;           
};
class Employee : public Person
{
public:
    std::string company;   
};
```

## Наслідування у С++

Наслідування в С++ дає можливість створювати нові класи на основі вже існуючих. Клас, який надає спадковість, називається базовим класом, а клас, який успадковує його властивості, називається похідним класом.

При створенні похідного класу він отримує доступ до всіх методів та змінних базового класу, крім тих, що оголошені як private.

Для створення похідного класу використовується ключове слово "class", а потім через двокрапку вказується назва базового класу, наприклад:

```cpp
class DerivedClass : access_specifier BaseClass
{
    // ...
};
```

Де **access_specifier** - це один із трьох модифікаторів доступу: public, private або protected, який визначає доступність успадкованих властивостей.

Якщо модифікатор доступу не вказаний, то вважається, що за замовчуванням використовується private.

Наприклад, якщо в базовому класі є метод foo() та змінна bar, то в похідному класі вони будуть доступні в такому вигляді:

```cpp
class BaseClass 
{
public:
    void foo() { /* ... */ }
protected:
    int bar;
};

class DerivedClass : public BaseClass
{
public:
    void baz()
    {
        foo(); // доступ до методу базового класу
        bar = 10; // доступ до змінної базового класу
    }
};
```

Для визначення поведінки успадкованих методів або змінних в похідному класі можна використовувати перевантаження операторів.

Наприклад, якщо в базовому класі є оператор "+" для додавання двох змінних, то його можна перевантажити в похідному класі, щоб здійснювати додавання змінних по-іншому.

## Абстрактні класи

**Абстрактний клас** - це клас, який містить хоча б один чистий віртуальний метод. 

**Віртуальний метод** - це метод, що може бути перевизначений у похідних класах, які наслідуються від базового класу. Для визначення віртуального методу в базовому класі використовується ключове слово virtual. Класи, які містять віртуальні методи, називаються поліморфними класами.

Віртуальний метод може мати реалізацію в базовому класі, яка буде використовуватися, якщо в похідних класах не буде перевизначено цей метод. Але якщо в похідному класі метод буде перевизначено, то буде використовуватися реалізація, яка знаходиться в похідному класі.

**Чистий віртуальний метод** - це метод, що не має реалізації в тілі класу та оголошується за допомогою ключового слова virtual та =0. Об'єкти абстрактного класу не можуть бути створені, але він може бути використаний як базовий клас для похідних класів.

У класі, який успадковує абстрактний клас, повинні бути реалізовані всі чисті віртуальні методи базового класу. Якщо цього не зробити, то похідний клас також стане абстрактним.

У С++ використовують ключове слово 'virtual' для визначення віртуальних методів. Крім того, віртуальний метод може бути зроблений чистим, за допомогою '=0'. Клас, що містить хоча б один чистий віртуальний метод, стає абстрактним класом, який не може бути створений, але може бути використаний як базовий для похідних класів.

```cpp
class Shape {
public:
    virtual double area() = 0;
    virtual double perimeter() = 0;
};
```

У цьому прикладі `Shape` є абстрактним класом, оскільки містить чисто віртуальні методи area() та perimeter(), які не мають жодної реалізації в самому класі. Об'єкти цього класу не можуть бути створені, але класи, які наслідуються від нього, повинні реалізувати всі його віртуальні методи, щоб бути визнаними як конкретні реалізації класу Shape.

## Наслідування та перевизначення методів

У мові програмування з наслідуванням класів ви можете успадкувати методи батьківського класу від дочірнього класу.

При наслідуванні методів, клас-нащадок може перевизначити методи, успадковані від батьківського класу. Це дозволяє змінювати поведінку методів нащадкового класу, щоб вони відповідали його потребам. Якщо метод не перевизначений в класі-нащадку, то буде використовуватися метод з батьківського класу.

У мові C++, наслідування методів досягається за допомогою ключового слова `virtual`. Якщо ви хочете перевизначити метод батьківського класу в дочірньому класі, ви можете використовувати ключове слово `override`. Наприклад:

```cpp
class Animal {
public:
    virtual void speak() {
        cout << "I am an animal" << endl;
    }
};

class Dog : public Animal {
public:
    void speak() override {
        cout << "I am a dog" << endl;
    }
};
```

Ключове слово `base` дозволяє викликати методи базового класу з методів класу-спадкоємця. 

```cpp
class Base {
public:
    virtual void foo() {
        std::cout << "Base::foo()" << std::endl;
    }
};

class Derived : public Base {
public:
    void foo() override {
        std::cout << "Derived::foo()" << std::endl;
        base::foo();
    }
};
```

## Наслідування конструкторів

В С++ при наслідуванні класу по замовчуванню конструктор базового класу не успадковується автоматично. Тому для того, щоб конструктор базового класу був викликаний, необхідно явно викликати його у тілі конструктора похідного класу.

Щоб викликати конструктор базового класу, потрібно використати список ініціалізації конструктора (initialization list) і передати необхідні аргументи конструктору базового класу.

Наприклад, якщо є базовий клас Animal з конструктором, який приймає параметр name, і похідний клас Cat, то для того, щоб конструктор Cat викликав конструктор Animal, необхідно вказати список ініціалізації конструктора у тілі конструктора Cat:

```cpp
class Animal {
public:
    Animal(string name) : m_name(name) {}
private:
    string m_name;
};

class Cat : public Animal {
public:
    Cat(string name, int age) : Animal(name), m_age(age) {}
private:
    int m_age;
};
```

У С++ для того, щоб викликати конструктор базового класу в конструкторі похідного класу, можна використовувати ключове слово `using`.


Наприклад, маємо базовий клас Person з конструктором, який приймає параметр name:

```cpp
class Person {
public:
    Person(std::string name) : name_(name) {}
protected:
    std::string name_;
};
```

І маємо похідний клас Student, який має свій конструктор, але ми хочемо використовувати конструктор базового класу для ініціалізації name_:

```cpp
class Student : public Person {
public:
    Student(std::string name, int id) : Person(name), id_(id) {}
private:
    int id_;
};
```

У цьому прикладі ми використовуємо using для того, щоб зробити конструктор базового класу доступним у конструкторі похідного класу. Оскільки ми передаємо параметр name до конструктора базового класу, ми можемо використовувати його для ініціалізації name_ у похідному класі.

```cpp
class Student : public Person {
public:
    using Person::Person;
    Student(std::string name, int id) : id_(id) {}
private:
    int id_;
};
```

У цьому прикладі ми використовуємо using для того, щоб зробити конструктор базового класу доступним у конструкторі похідного класу без явного виклику конструктора базового класу. Конструктор похідного класу може приймати параметр name, який буде передано до конструктора базового класу, ініціалізуючи name_, а параметр id ініціалізує id_.

## Наслідування деструкторів

У C++ деструктор базового класу автоматично викликається після виконання деструктора похідного класу. Це означає, що якщо у класі-нащадку не визначено свого деструктора, то буде використовуватися деструктор базового класу. Якщо ж у класі-нащадку визначено свій деструктор, то можна вказати виклик деструктора базового класу за допомогою ключового слова virtual.

Для виклику деструктора базового класу в деструкторі похідного класу використовується синтаксис з двокрапкою та іменем базового класу. Наприклад, якщо ми маємо похідний клас Derived від базового класу Base, то для виклику деструктора базового класу в деструкторі класу Derived використовується наступний синтаксис:

```cpp
Derived::~Derived()
{
    // ... код деструктора похідного класу ...
    // Виклик деструктора базового класу
    Base::~Base();
}
```

